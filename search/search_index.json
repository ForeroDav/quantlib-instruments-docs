{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QuantLib Financial Instruments Documentation","text":"Professional Pricing &amp; Valuation Platform <p>Comprehensive documentation for QuantLib-based financial instruments</p> Get Started Browse Instruments"},{"location":"#platform-overview","title":"\ud83d\udcca Platform Overview","text":"16+ Instruments 6 Asset Classes 15+ Pricing Models 100% Production Ready"},{"location":"#supported-instruments-by-asset-class","title":"\ud83c\udfaf Supported Instruments by Asset Class","text":"<ul> <li> <p> Equity Derivatives (8)</p> <p>Options &amp; Warrants: - American Options - European Options - American Warrants</p> <p>Swaps &amp; Futures: - Equity Swaps - Equity Index Swaps - Preferred Equity Swaps - Equity Index Futures - Equity Future Swaps</p> <p> Explore Equity \u2192</p> </li> <li> <p> Fixed Income (3)</p> <p>Government Securities: - Treasury Bonds</p> <p>Corporate Debt: - Callable Bonds - Floating Rate Notes (FRN)</p> <p>Features: - Yield curve bootstrapping - Duration &amp; convexity - Embedded options pricing</p> <p> Explore Fixed Income \u2192</p> </li> <li> <p> Credit Derivatives (3)</p> <p>Single-Name: - Credit Default Swaps (CDS)</p> <p>Index Products: - CDS Indices - CDX / iTraxx Options</p> <p>Models: - ISDA Standard Model - Hazard Rate Framework - Recovery Rate Analysis</p> <p> Explore Credit \u2192</p> </li> <li> <p> Interest Rates (1)</p> <p>Vanilla Swaps: - Interest Rate Swaps (IRS)</p> <p>Features: - Multi-curve framework - OIS discounting - CVA/DVA adjustments</p> <p>Curves: - LIBOR/SOFR - OIS curves - Basis spreads</p> <p> Explore Rates \u2192</p> </li> <li> <p> Foreign Exchange (1)</p> <p>FX Derivatives: - Currency Forwards</p> <p>Pricing: - Covered Interest Parity - Forward points - Cross-currency basis</p> <p>Applications: - Hedging - Arbitrage - Speculation</p> <p> Explore FX \u2192</p> </li> <li> <p> Cash Flow Instruments (4)</p> <p>Categories: - Non-Performing - Performing - Fixed Rate - Performing - Floating Rate - Performing - Supplied</p> <p>Analytics: - NPV calculation - Cash flow scheduling - Payment waterfalls</p> <p> Cash Flow Overview \u2192</p> </li> </ul>"},{"location":"#system-architecture","title":"\ud83c\udfd7\ufe0f System Architecture","text":"<pre><code>graph TD\n    A[Market Data Layer] --&gt; B[Instrument Layer]\n    B --&gt; C[Pricing Engine Layer]\n    C --&gt; D[Results Layer]\n\n    A --&gt; A1[Yield Curves]\n    A --&gt; A2[Volatility Surfaces]\n    A --&gt; A3[Correlations]\n\n    B --&gt; B1[Equity]\n    B --&gt; B2[Fixed Income]\n    B --&gt; B3[Credit]\n    B --&gt; B4[Rates/FX]\n\n    C --&gt; C1[Analytical]\n    C --&gt; C2[Monte Carlo]\n    C --&gt; C3[PDE/FD]\n    C --&gt; C4[Tree Methods]\n\n    D --&gt; D1[NPV]\n    D --&gt; D2[Greeks]\n    D --&gt; D3[Risk Metrics]\n\n    style A fill:#4CAF50,color:#fff\n    style B fill:#2196F3,color:#fff\n    style C fill:#FF9800,color:#fff\n    style D fill:#9C27B0,color:#fff</code></pre>"},{"location":"#quick-start-example","title":"\ud83d\udcbb Quick Start Example","text":"<p>Price a European call option in under 20 lines of code:</p> PythonOutput <pre><code>import QuantLib as ql\n\n# 1. Set evaluation date\ncalc_date = ql.Date(15, 1, 2025)\nql.Settings.instance().evaluationDate = calc_date\n\n# 2. Define market data\nspot = 100.0\nstrike = 105.0\nvolatility = 0.20\nrisk_free_rate = 0.05\ndividend_yield = 0.02\nmaturity = ql.Date(15, 6, 2025)\n\n# 3. Create option\npayoff = ql.PlainVanillaPayoff(ql.Option.Call, strike)\nexercise = ql.EuropeanExercise(maturity)\noption = ql.VanillaOption(payoff, exercise)\n\n# 4. Set up Black-Scholes process\nspot_handle = ql.QuoteHandle(ql.SimpleQuote(spot))\nflat_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calc_date, risk_free_rate, ql.Actual365Fixed())\n)\ndividend_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calc_date, dividend_yield, ql.Actual365Fixed())\n)\nflat_vol_ts = ql.BlackVolTermStructureHandle(\n    ql.BlackConstantVol(calc_date, ql.NullCalendar(),\n                       volatility, ql.Actual365Fixed())\n)\n\nbs_process = ql.BlackScholesMertonProcess(\n    spot_handle, dividend_ts, flat_ts, flat_vol_ts\n)\n\n# 5. Price the option\noption.setPricingEngine(ql.AnalyticEuropeanEngine(bs_process))\n\n# 6. Get results\nprint(f\"Option Price: ${option.NPV():.2f}\")\nprint(f\"Delta: {option.delta():.4f}\")\nprint(f\"Gamma: {option.gamma():.6f}\")\nprint(f\"Vega: {option.vega():.4f}\")\n</code></pre> <pre><code>Option Price: $4.76\nDelta: 0.4512\nGamma: 0.024532\nVega: 26.4521\n</code></pre>"},{"location":"#complete-instrument-catalog","title":"\ud83d\udcda Complete Instrument Catalog","text":""},{"location":"#equity-instruments-8","title":"Equity Instruments (8)","text":"#### EQUITY Options &amp; Derivatives  | Instrument | Type | Pricing Methods | Documentation | |------------|------|-----------------|---------------| | **EquityAmericanOption** | Vanilla Option | Binomial Tree, FD, LSM | [View \u2192](instruments/equity/american_option.md) | | **EquityEuropeanOption** | Vanilla Option | Black-Scholes, Monte Carlo | [View \u2192](instruments/equity/european_option.md) | | **EquityAmericanWarrant** | Warrant | Binomial Tree, Dilution Model | [View \u2192](instruments/equity/american_warrant.md) | | **EquitySwap** | Total Return Swap | Monte Carlo, PDE | [View \u2192](instruments/equity/equity_swap.md) | | **EquityIndexSwap** | Index Swap | Index Replication | [View \u2192](instruments/equity/equity_index_swap.md) | | **EquityPreferredSwap** | Preferred Equity | DDM, Cash Flow | [View \u2192](instruments/equity/equity_swap.md) | | **EquityIndexFutures** | Futures | Cost of Carry | [View \u2192](instruments/equity/index_futures.md) | | **EquityFutureSwap** | Futures Swap | Forward Pricing | [View \u2192](instruments/equity/equity_swap.md) |"},{"location":"#fixed-income-instruments-3","title":"Fixed Income Instruments (3)","text":"#### FIXED INCOME Bonds &amp; Notes  | Instrument | Type | Pricing Methods | Documentation | |------------|------|-----------------|---------------| | **TreasuryBond** | Government Bond | Yield Curve Bootstrap | [View \u2192](instruments/fixed_income/treasury_bond.md) | | **CallableBond** | Callable Bond | Hull-White, BDT | [View \u2192](instruments/fixed_income/callable_bond.md) | | **FloatingRateNote** | Floating Note | Discounted Cash Flow | [View \u2192](instruments/fixed_income/frn.md) |"},{"location":"#credit-derivatives-3","title":"Credit Derivatives (3)","text":"#### CREDIT Credit Protection  | Instrument | Type | Pricing Methods | Documentation | |------------|------|-----------------|---------------| | **CreditDefaultSwap** | Single-Name CDS | ISDA Standard, Hazard Rate | [View \u2192](instruments/credit/cds.md) | | **CreditDefaultSwapIndex** | Index CDS | Index Model | [View \u2192](instruments/credit/cds_index.md) | | **CDX/iTraxx Options** | Index Options | Black's Model | [View \u2192](instruments/credit/cdx_options.md) |"},{"location":"#learning-path","title":"\ud83c\udf93 Learning Path","text":"<pre><code>graph LR\n    A[Installation] --&gt; B[Quick Start]\n    B --&gt; C[Basic Instruments]\n    C --&gt; D[Advanced Pricing]\n    D --&gt; E[Risk Management]\n\n    style A fill:#4CAF50,color:#fff\n    style B fill:#2196F3,color:#fff\n    style C fill:#FF9800,color:#fff\n    style D fill:#9C27B0,color:#fff\n    style E fill:#F44336,color:#fff</code></pre>          \ud83d\udce6 Installation               \ud83d\ude80 Quick Start               \ud83d\udcca Instruments               \ud83d\udcbb Examples"},{"location":"#key-features","title":"\u26a1 Key Features","text":"<p>Production-Ready Code</p> <p>All examples are tested with real QuantLib implementation and ready for production use.</p> <p>Comprehensive Documentation</p> <p>Each instrument includes theory, pricing methods, code examples, and use cases.</p> <p>Interactive Examples</p> <p>Jupyter notebooks with live code you can run and modify.</p> <p>Best Practices</p> <p>Industry-standard approaches and battle-tested implementations.</p>"},{"location":"#pricing-methods-overview","title":"\ud83d\udd2c Pricing Methods Overview","text":"Analytical Methods <ul> <li>Black-Scholes</li> <li>Black's Model</li> <li>Closed-form Solutions</li> </ul> Tree Methods <ul> <li>Binomial Trees</li> <li>Trinomial Trees</li> <li>BDT, Hull-White</li> </ul> Monte Carlo <ul> <li>Path Simulation</li> <li>LSM (American)</li> <li>Variance Reduction</li> </ul> PDE Methods <ul> <li>Finite Difference</li> <li>Crank-Nicolson</li> <li>Explicit/Implicit</li> </ul>"},{"location":"#whats-next","title":"\ud83d\udcd6 What's Next?","text":"<p>Built with QuantLib | Documented with MkDocs Material</p> <p>\u00a9 2025 David Forero | Production-Ready Financial Instruments Documentation</p>"},{"location":"#for-quants-developers","title":"For Quants &amp; Developers","text":"<ol> <li>Installation Guide - Set up your environment</li> <li>Quick Start - Your first pricing</li> <li>Equity Options - Detailed example</li> <li>Interactive Examples - Jupyter notebooks</li> </ol>"},{"location":"#for-risk-managers","title":"For Risk Managers","text":"<ol> <li>Instrument Catalog - Browse all instruments</li> <li>Pricing Methods - Compare approaches</li> <li>Greeks &amp; Risk Metrics - Sensitivity analysis</li> <li>API Reference - Complete technical docs</li> </ol>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for QuantLib instruments.</p>"},{"location":"api/#core-classes","title":"Core Classes","text":""},{"location":"api/#instrument-base-class","title":"Instrument Base Class","text":"<p>All instruments inherit from the base <code>Instrument</code> class:</p> <pre><code>class Instrument:\n    \"\"\"Base class for all financial instruments\"\"\"\n    def NPV(self) -&gt; float:\n        \"\"\"Net Present Value of the instrument\"\"\"\n        pass\n\n    def setPricingEngine(self, engine):\n        \"\"\"Set the pricing engine\"\"\"\n        pass\n</code></pre>"},{"location":"api/#equity-instruments","title":"Equity Instruments","text":"<ul> <li><code>EquitySwap</code></li> <li><code>EquityIndexSwap</code></li> <li><code>EquityAmericanOption</code></li> <li><code>EquityEuropeanOption</code></li> <li><code>EquityIndexFutures</code></li> </ul>"},{"location":"api/#fixed-income-instruments","title":"Fixed Income Instruments","text":"<ul> <li><code>TreasuryBond</code></li> <li><code>CallableBond</code></li> <li><code>FloatingRateNote</code></li> </ul>"},{"location":"api/#credit-derivatives","title":"Credit Derivatives","text":"<ul> <li><code>CreditDefaultSwap</code></li> <li><code>CreditDefaultSwapIndex</code></li> </ul>"},{"location":"api/#see-documentation","title":"See Documentation","text":"<p>For detailed API documentation, see individual instrument pages in the Instruments section.</p>"},{"location":"examples/advanced_valuation/","title":"Advanced Valuation Techniques","text":""},{"location":"examples/advanced_valuation/#advanced-valuation-techniques","title":"Advanced Valuation Techniques\u00b6","text":"<p>Advanced pricing methods and risk analysis.</p>"},{"location":"examples/advanced_valuation/#topics","title":"Topics\u00b6","text":"<ul> <li>Monte Carlo simulation</li> <li>PDE methods</li> <li>Calibration</li> <li>Risk metrics</li> </ul> <p>Content coming soon</p>"},{"location":"examples/advanced_valuation.ipynb/","title":"Advanced Valuation","text":""},{"location":"examples/basic_pricing/","title":"Basic Instrument Pricing with QuantLib","text":"In\u00a0[\u00a0]: Copied! <pre># Import libraries\nimport QuantLib as ql\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nprint(f\"QuantLib version: {ql.__version__}\")\n</pre> # Import libraries import QuantLib as ql import numpy as np import pandas as pd import matplotlib.pyplot as plt  print(f\"QuantLib version: {ql.__version__}\") In\u00a0[\u00a0]: Copied! <pre># Set global evaluation date\ncalculation_date = ql.Date(15, 1, 2025)\nql.Settings.instance().evaluationDate = calculation_date\n\nprint(f\"Evaluation Date: {calculation_date}\")\n</pre> # Set global evaluation date calculation_date = ql.Date(15, 1, 2025) ql.Settings.instance().evaluationDate = calculation_date  print(f\"Evaluation Date: {calculation_date}\") In\u00a0[\u00a0]: Copied! <pre># Option parameters\nunderlying_price = 100.0\nstrike_price = 105.0\nvolatility = 0.20\nrisk_free_rate = 0.05\ndividend_yield = 0.02\nmaturity_date = ql.Date(15, 6, 2025)\n\n# Create option\npayoff = ql.PlainVanillaPayoff(ql.Option.Call, strike_price)\nexercise = ql.EuropeanExercise(maturity_date)\neuropean_option = ql.VanillaOption(payoff, exercise)\n\n# Market data\nspot_handle = ql.QuoteHandle(ql.SimpleQuote(underlying_price))\nflat_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, risk_free_rate, ql.Actual365Fixed())\n)\ndividend_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, dividend_yield, ql.Actual365Fixed())\n)\nflat_vol_ts = ql.BlackVolTermStructureHandle(\n    ql.BlackConstantVol(calculation_date, ql.NullCalendar(), volatility, ql.Actual365Fixed())\n)\n\n# Pricing engine\nbs_process = ql.BlackScholesMertonProcess(spot_handle, dividend_ts, flat_ts, flat_vol_ts)\nengine = ql.AnalyticEuropeanEngine(bs_process)\neuropean_option.setPricingEngine(engine)\n\n# Results\nprint(\"\\n=== European Call Option ===\")\nprint(f\"Spot Price: ${underlying_price}\")\nprint(f\"Strike Price: ${strike_price}\")\nprint(f\"Volatility: {volatility*100:.1f}%\")\nprint(f\"\\nOption Price: ${european_option.NPV():.2f}\")\nprint(f\"Delta: {european_option.delta():.4f}\")\nprint(f\"Gamma: {european_option.gamma():.6f}\")\nprint(f\"Vega: {european_option.vega():.4f}\")\nprint(f\"Theta: {european_option.theta():.4f}\")\nprint(f\"Rho: {european_option.rho():.4f}\")\n</pre> # Option parameters underlying_price = 100.0 strike_price = 105.0 volatility = 0.20 risk_free_rate = 0.05 dividend_yield = 0.02 maturity_date = ql.Date(15, 6, 2025)  # Create option payoff = ql.PlainVanillaPayoff(ql.Option.Call, strike_price) exercise = ql.EuropeanExercise(maturity_date) european_option = ql.VanillaOption(payoff, exercise)  # Market data spot_handle = ql.QuoteHandle(ql.SimpleQuote(underlying_price)) flat_ts = ql.YieldTermStructureHandle(     ql.FlatForward(calculation_date, risk_free_rate, ql.Actual365Fixed()) ) dividend_ts = ql.YieldTermStructureHandle(     ql.FlatForward(calculation_date, dividend_yield, ql.Actual365Fixed()) ) flat_vol_ts = ql.BlackVolTermStructureHandle(     ql.BlackConstantVol(calculation_date, ql.NullCalendar(), volatility, ql.Actual365Fixed()) )  # Pricing engine bs_process = ql.BlackScholesMertonProcess(spot_handle, dividend_ts, flat_ts, flat_vol_ts) engine = ql.AnalyticEuropeanEngine(bs_process) european_option.setPricingEngine(engine)  # Results print(\"\\n=== European Call Option ===\") print(f\"Spot Price: ${underlying_price}\") print(f\"Strike Price: ${strike_price}\") print(f\"Volatility: {volatility*100:.1f}%\") print(f\"\\nOption Price: ${european_option.NPV():.2f}\") print(f\"Delta: {european_option.delta():.4f}\") print(f\"Gamma: {european_option.gamma():.6f}\") print(f\"Vega: {european_option.vega():.4f}\") print(f\"Theta: {european_option.theta():.4f}\") print(f\"Rho: {european_option.rho():.4f}\") In\u00a0[\u00a0]: Copied! <pre># American option\namerican_exercise = ql.AmericanExercise(calculation_date, maturity_date)\namerican_option = ql.VanillaOption(payoff, american_exercise)\n\n# Binomial engine\nbinomial_engine = ql.BinomialVanillaEngine(bs_process, \"crr\", 100)\namerican_option.setPricingEngine(binomial_engine)\n\n# Comparison\neuro_price = european_option.NPV()\namer_price = american_option.NPV()\npremium = amer_price - euro_price\n\nprint(\"\\n=== European vs American Option ===\")\nprint(f\"European Price: ${euro_price:.2f}\")\nprint(f\"American Price: ${amer_price:.2f}\")\nprint(f\"Early Exercise Premium: ${premium:.2f} ({premium/euro_price*100:.2f}%)\")\n</pre> # American option american_exercise = ql.AmericanExercise(calculation_date, maturity_date) american_option = ql.VanillaOption(payoff, american_exercise)  # Binomial engine binomial_engine = ql.BinomialVanillaEngine(bs_process, \"crr\", 100) american_option.setPricingEngine(binomial_engine)  # Comparison euro_price = european_option.NPV() amer_price = american_option.NPV() premium = amer_price - euro_price  print(\"\\n=== European vs American Option ===\") print(f\"European Price: ${euro_price:.2f}\") print(f\"American Price: ${amer_price:.2f}\") print(f\"Early Exercise Premium: ${premium:.2f} ({premium/euro_price*100:.2f}%)\") In\u00a0[\u00a0]: Copied! <pre># Create volatility surface\nstrikes = np.linspace(80, 120, 9)\nvols = np.linspace(0.15, 0.30, 5)\n\nresults = []\n\nfor vol in vols:\n    vol_prices = []\n    for strike in strikes:\n        # Create option with new strike\n        payoff = ql.PlainVanillaPayoff(ql.Option.Call, strike)\n        option = ql.VanillaOption(payoff, exercise)\n        \n        # Update volatility\n        vol_ts = ql.BlackVolTermStructureHandle(\n            ql.BlackConstantVol(calculation_date, ql.NullCalendar(), vol, ql.Actual365Fixed())\n        )\n        process = ql.BlackScholesMertonProcess(spot_handle, dividend_ts, flat_ts, vol_ts)\n        option.setPricingEngine(ql.AnalyticEuropeanEngine(process))\n        \n        vol_prices.append(option.NPV())\n    \n    results.append(vol_prices)\n\n# Plot\nplt.figure(figsize=(12, 6))\nfor i, vol in enumerate(vols):\n    plt.plot(strikes, results[i], marker='o', label=f'Vol = {vol*100:.0f}%')\n\nplt.axvline(x=underlying_price, color='red', linestyle='--', label='Spot Price')\nplt.xlabel('Strike Price')\nplt.ylabel('Option Price ($)')\nplt.title('European Call Option Prices vs Strike and Volatility')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</pre> # Create volatility surface strikes = np.linspace(80, 120, 9) vols = np.linspace(0.15, 0.30, 5)  results = []  for vol in vols:     vol_prices = []     for strike in strikes:         # Create option with new strike         payoff = ql.PlainVanillaPayoff(ql.Option.Call, strike)         option = ql.VanillaOption(payoff, exercise)                  # Update volatility         vol_ts = ql.BlackVolTermStructureHandle(             ql.BlackConstantVol(calculation_date, ql.NullCalendar(), vol, ql.Actual365Fixed())         )         process = ql.BlackScholesMertonProcess(spot_handle, dividend_ts, flat_ts, vol_ts)         option.setPricingEngine(ql.AnalyticEuropeanEngine(process))                  vol_prices.append(option.NPV())          results.append(vol_prices)  # Plot plt.figure(figsize=(12, 6)) for i, vol in enumerate(vols):     plt.plot(strikes, results[i], marker='o', label=f'Vol = {vol*100:.0f}%')  plt.axvline(x=underlying_price, color='red', linestyle='--', label='Spot Price') plt.xlabel('Strike Price') plt.ylabel('Option Price ($)') plt.title('European Call Option Prices vs Strike and Volatility') plt.legend() plt.grid(True, alpha=0.3) plt.show() In\u00a0[\u00a0]: Copied! <pre># Swap parameters\nnominal = 1_000_000\nfixed_rate = 0.05\nmaturity_years = 5\n\n# Dates\neffective_date = calculation_date\ntermination_date = calculation_date + ql.Period(maturity_years, ql.Years)\n\n# Schedules\nfixed_schedule = ql.Schedule(\n    effective_date, termination_date,\n    ql.Period(ql.Annual), ql.TARGET(),\n    ql.ModifiedFollowing, ql.ModifiedFollowing,\n    ql.DateGeneration.Forward, False\n)\n\nfloat_schedule = ql.Schedule(\n    effective_date, termination_date,\n    ql.Period(ql.Semiannual), ql.TARGET(),\n    ql.ModifiedFollowing, ql.ModifiedFollowing,\n    ql.DateGeneration.Forward, False\n)\n\n# Create swap\nswap = ql.VanillaSwap(\n    ql.VanillaSwap.Payer, nominal,\n    fixed_schedule, fixed_rate, ql.Actual360(),\n    float_schedule, ql.Euribor6M(), 0.0, ql.Actual360()\n)\n\nprint(\"\\n=== Interest Rate Swap ===\")\nprint(f\"Notional: ${nominal:,}\")\nprint(f\"Fixed Rate: {fixed_rate*100:.2f}%\")\nprint(f\"Maturity: {maturity_years} years\")\nprint(f\"\\nSwap Type: Payer (pay fixed, receive floating)\")\nprint(f\"Fixed Leg Payments: {len(fixed_schedule) - 1}\")\nprint(f\"Float Leg Payments: {len(float_schedule) - 1}\")\n</pre> # Swap parameters nominal = 1_000_000 fixed_rate = 0.05 maturity_years = 5  # Dates effective_date = calculation_date termination_date = calculation_date + ql.Period(maturity_years, ql.Years)  # Schedules fixed_schedule = ql.Schedule(     effective_date, termination_date,     ql.Period(ql.Annual), ql.TARGET(),     ql.ModifiedFollowing, ql.ModifiedFollowing,     ql.DateGeneration.Forward, False )  float_schedule = ql.Schedule(     effective_date, termination_date,     ql.Period(ql.Semiannual), ql.TARGET(),     ql.ModifiedFollowing, ql.ModifiedFollowing,     ql.DateGeneration.Forward, False )  # Create swap swap = ql.VanillaSwap(     ql.VanillaSwap.Payer, nominal,     fixed_schedule, fixed_rate, ql.Actual360(),     float_schedule, ql.Euribor6M(), 0.0, ql.Actual360() )  print(\"\\n=== Interest Rate Swap ===\") print(f\"Notional: ${nominal:,}\") print(f\"Fixed Rate: {fixed_rate*100:.2f}%\") print(f\"Maturity: {maturity_years} years\") print(f\"\\nSwap Type: Payer (pay fixed, receive floating)\") print(f\"Fixed Leg Payments: {len(fixed_schedule) - 1}\") print(f\"Float Leg Payments: {len(float_schedule) - 1}\") In\u00a0[\u00a0]: Copied! <pre># Summary of instruments\ninstruments_data = {\n    'Instrument': [\n        'European Call',\n        'European Put',\n        'American Call',\n        'American Put'\n    ],\n    'Category': ['Equity'] * 4,\n    'Strike': [105.0] * 4,\n    'Spot': [100.0] * 4\n}\n\n# Calculate prices\nprices = []\n\nfor opt_type in [ql.Option.Call, ql.Option.Put]:\n    # European\n    payoff = ql.PlainVanillaPayoff(opt_type, strike_price)\n    euro = ql.VanillaOption(payoff, exercise)\n    euro.setPricingEngine(engine)\n    prices.append(euro.NPV())\n    \n    # American\n    amer = ql.VanillaOption(payoff, american_exercise)\n    amer.setPricingEngine(binomial_engine)\n    prices.append(amer.NPV())\n\ninstruments_data['Price ($)'] = prices\n\n# Create DataFrame\ndf = pd.DataFrame(instruments_data)\nprint(\"\\n=== Instrument Pricing Summary ===\")\nprint(df.to_string(index=False))\n</pre> # Summary of instruments instruments_data = {     'Instrument': [         'European Call',         'European Put',         'American Call',         'American Put'     ],     'Category': ['Equity'] * 4,     'Strike': [105.0] * 4,     'Spot': [100.0] * 4 }  # Calculate prices prices = []  for opt_type in [ql.Option.Call, ql.Option.Put]:     # European     payoff = ql.PlainVanillaPayoff(opt_type, strike_price)     euro = ql.VanillaOption(payoff, exercise)     euro.setPricingEngine(engine)     prices.append(euro.NPV())          # American     amer = ql.VanillaOption(payoff, american_exercise)     amer.setPricingEngine(binomial_engine)     prices.append(amer.NPV())  instruments_data['Price ($)'] = prices  # Create DataFrame df = pd.DataFrame(instruments_data) print(\"\\n=== Instrument Pricing Summary ===\") print(df.to_string(index=False))"},{"location":"examples/basic_pricing/#basic-instrument-pricing-with-quantlib","title":"Basic Instrument Pricing with QuantLib\u00b6","text":"<p>This notebook demonstrates pricing various financial instruments using QuantLib.</p>"},{"location":"examples/basic_pricing/#setup-evaluation-date","title":"Setup: Evaluation Date\u00b6","text":"<p>All pricing starts by setting the evaluation date:</p>"},{"location":"examples/basic_pricing/#example-1-european-equity-option","title":"Example 1: European Equity Option\u00b6","text":"<p>Price a European call option using Black-Scholes.</p>"},{"location":"examples/basic_pricing/#example-2-american-option-comparison","title":"Example 2: American Option Comparison\u00b6","text":"<p>Compare American and European option prices.</p>"},{"location":"examples/basic_pricing/#example-3-volatility-surface-analysis","title":"Example 3: Volatility Surface Analysis\u00b6","text":""},{"location":"examples/basic_pricing/#example-4-interest-rate-swap","title":"Example 4: Interest Rate Swap\u00b6","text":"<p>Price a vanilla interest rate swap.</p>"},{"location":"examples/basic_pricing/#example-5-multiple-instruments-summary","title":"Example 5: Multiple Instruments Summary\u00b6","text":"<p>Create a summary table of different instruments.</p>"},{"location":"examples/basic_pricing/#summary","title":"Summary\u00b6","text":"<p>This notebook demonstrated:</p> <ul> <li>\u2705 European and American option pricing</li> <li>\u2705 Greeks calculation</li> <li>\u2705 Volatility surface analysis</li> <li>\u2705 Interest rate swap setup</li> <li>\u2705 Multi-instrument comparison</li> </ul>"},{"location":"examples/basic_pricing/#next-steps","title":"Next Steps\u00b6","text":"<ul> <li>Explore Advanced Valuation</li> <li>Review Instrument Documentation</li> <li>Check API Reference</li> </ul>"},{"location":"guides/installation/","title":"Installation Guide","text":""},{"location":"guides/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.8+</li> <li>C++ compiler (for QuantLib)</li> <li>pip</li> </ul>"},{"location":"guides/installation/#install-quantlib-python","title":"Install QuantLib-Python","text":"<pre><code>pip install QuantLib-Python\n</code></pre>"},{"location":"guides/installation/#install-additional-dependencies","title":"Install Additional Dependencies","text":"<pre><code>pip install numpy pandas matplotlib jupyter\n</code></pre>"},{"location":"guides/installation/#verify-installation","title":"Verify Installation","text":"<pre><code>import QuantLib as ql\nprint(f\"QuantLib version: {ql.__version__}\")\n</code></pre>"},{"location":"guides/installation/#next-steps","title":"Next Steps","text":"<p>Continue to the Quick Start Guide</p>"},{"location":"guides/quickstart/","title":"Quick Start Guide","text":"<p>Get started with QuantLib instruments pricing in minutes.</p>"},{"location":"guides/quickstart/#installation","title":"Installation","text":"<pre><code>pip install QuantLib-Python numpy pandas matplotlib\n</code></pre>"},{"location":"guides/quickstart/#basic-workflow","title":"Basic Workflow","text":"<p>Every pricing operation follows these steps:</p> <pre><code>flowchart LR\n    A[Set Evaluation Date] --&gt; B[Define Instrument]\n    B --&gt; C[Set Market Data]\n    C --&gt; D[Choose Pricing Engine]\n    D --&gt; E[Calculate Price]\n    E --&gt; F[Extract Results]</code></pre>"},{"location":"guides/quickstart/#your-first-pricing-european-option","title":"Your First Pricing: European Option","text":"<pre><code>import QuantLib as ql\nfrom datetime import datetime\n\n# Step 1: Set evaluation date\ncalc_date = ql.Date(15, 1, 2025)\nql.Settings.instance().evaluationDate = calc_date\n\n# Step 2: Define the instrument\nstrike = 105.0\nmaturity = ql.Date(15, 6, 2025)\npayoff = ql.PlainVanillaPayoff(ql.Option.Call, strike)\nexercise = ql.EuropeanExercise(maturity)\noption = ql.VanillaOption(payoff, exercise)\n\n# Step 3: Set market data\nspot = 100.0\nvolatility = 0.20\nrisk_free_rate = 0.05\ndividend_yield = 0.02\n\nspot_handle = ql.QuoteHandle(ql.SimpleQuote(spot))\nflat_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calc_date, risk_free_rate, ql.Actual365Fixed())\n)\ndividend_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calc_date, dividend_yield, ql.Actual365Fixed())\n)\nflat_vol_ts = ql.BlackVolTermStructureHandle(\n    ql.BlackConstantVol(calc_date, ql.NullCalendar(), volatility, ql.Actual365Fixed())\n)\n\n# Step 4: Create pricing engine\nbs_process = ql.BlackScholesMertonProcess(spot_handle, dividend_ts, flat_ts, flat_vol_ts)\nengine = ql.AnalyticEuropeanEngine(bs_process)\noption.setPricingEngine(engine)\n\n# Step 5: Get results\nprint(f\"Option Price: ${option.NPV():.2f}\")\nprint(f\"Delta: {option.delta():.4f}\")\nprint(f\"Gamma: {option.gamma():.6f}\")\nprint(f\"Vega: {option.vega():.4f}\")\n</code></pre>"},{"location":"guides/quickstart/#next-interest-rate-swap","title":"Next: Interest Rate Swap","text":"<pre><code># Define swap parameters\nnominal = 1_000_000\nfixed_rate = 0.05\nmaturity_years = 5\n\n# Create schedules\neffective_date = calc_date\ntermination_date = calc_date + ql.Period(maturity_years, ql.Years)\n\nfixed_schedule = ql.Schedule(\n    effective_date, termination_date,\n    ql.Period(ql.Annual), ql.TARGET(),\n    ql.ModifiedFollowing, ql.ModifiedFollowing,\n    ql.DateGeneration.Forward, False\n)\n\nfloat_schedule = ql.Schedule(\n    effective_date, termination_date,\n    ql.Period(ql.Semiannual), ql.TARGET(),\n    ql.ModifiedFollowing, ql.ModifiedFollowing,\n    ql.DateGeneration.Forward, False\n)\n\n# Create swap\nswap = ql.VanillaSwap(\n    ql.VanillaSwap.Payer, nominal,\n    fixed_schedule, fixed_rate, ql.Actual360(),\n    float_schedule, ql.Euribor6M(), 0.0, ql.Actual360()\n)\n\nprint(f\"Swap NPV: ${swap.NPV():,.2f}\")\n</code></pre>"},{"location":"guides/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/quickstart/#pattern-1-pricing-with-different-engines","title":"Pattern 1: Pricing with Different Engines","text":"<pre><code>engines = {\n    \"Analytic\": ql.AnalyticEuropeanEngine(bs_process),\n    \"MC (10k paths)\": ql.MCEuropeanEngine(bs_process, \"PseudoRandom\", timeSteps=20, requiredSamples=10000),\n    \"FD\": ql.FdBlackScholesVanillaEngine(bs_process, 100, 100)\n}\n\nfor name, eng in engines.items():\n    option.setPricingEngine(eng)\n    print(f\"{name:20s}: ${option.NPV():.2f}\")\n</code></pre>"},{"location":"guides/quickstart/#pattern-2-greeks-calculation","title":"Pattern 2: Greeks Calculation","text":"<pre><code>def calculate_greeks(option):\n    return {\n        'price': option.NPV(),\n        'delta': option.delta(),\n        'gamma': option.gamma(),\n        'vega': option.vega() / 100,  # per 1% vol change\n        'theta': option.theta() / 365,  # per day\n        'rho': option.rho() / 100  # per 1% rate change\n    }\n\ngreeks = calculate_greeks(option)\nfor name, value in greeks.items():\n    print(f\"{name.capitalize():10s}: {value:10.4f}\")\n</code></pre>"},{"location":"guides/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>Browse all instruments</li> <li>See pricing examples</li> <li>Read API reference</li> </ul>"},{"location":"instruments/","title":"Financial Instruments Overview","text":"<p>Complete reference for all supported financial instruments.</p>"},{"location":"instruments/#instruments-by-category","title":"Instruments by Category","text":""},{"location":"instruments/#equity-instruments","title":"Equity Instruments","text":"Instrument Class Description Pricing Methods EquitySwap Exchange of cash flows based on equity return Monte Carlo, PDE EquityIndexSwap Swap based on equity index performance Index Replication EquityAmericanWarrant American-style equity warrant Binomial Tree, Finite Difference EquityAmericanOption American-style equity option LSM, Binomial Tree EquityEuropeanOption European-style equity option Black-Scholes, Monte Carlo EquityPreferredSwap Swap on preferred stock Dividend Discount Model EquityIndexFutures Futures on equity index Cost of Carry EquityFutureSwap Swap on equity futures Futures Pricing <p>Explore Equity Instruments \u2192</p>"},{"location":"instruments/#fixed-income-instruments","title":"Fixed Income Instruments","text":"Instrument Class Description Pricing Methods TreasuryBond Government-issued bond Yield Curve Bootstrapping CallableBond Bond with embedded call option Hull-White, Black-Derman-Toy FloatingRateNote Variable rate bond Discounted Cash Flow, LIBOR Curve <p>Explore Fixed Income \u2192</p>"},{"location":"instruments/#credit-derivatives","title":"Credit Derivatives","text":"Instrument Class Description Pricing Methods CreditDefaultSwap Protection against credit events Hazard Rate Model, ISDA Standard CreditDefaultSwapIndex CDS on index of credits Index CDS Model CDX / iTraxx Options Options on CDS indices Black's Model <p>Explore Credit Derivatives \u2192</p>"},{"location":"instruments/#interest-rate-derivatives","title":"Interest Rate Derivatives","text":"Instrument Class Description Pricing Methods InterestRateSwap Exchange of fixed/floating payments Multi-Curve Framework, OIS Discounting <p>Explore Interest Rate Derivatives \u2192</p>"},{"location":"instruments/#fx-derivatives","title":"FX Derivatives","text":"Instrument Class Description Pricing Methods CurrencyForward Forward contract on FX pair Covered Interest Parity <p>Explore FX Derivatives \u2192</p>"},{"location":"instruments/#cash-flow-instruments","title":"Cash Flow Instruments","text":"Instrument Class Description CashFlow:NonPerforming Non-performing cash flows CashFlow:PerformingSupplied Performing supplied cash flows CashFlow:PerformingFloatingRate Floating rate performing cash flows CashFlow:PerformingFixedRate Fixed rate performing cash flows <p>Explore Cash Flow Instruments \u2192</p>"},{"location":"instruments/#instrument-categories","title":"Instrument Categories","text":"<pre><code>%%{init: {'theme':'base', 'themeVariables': { 'primaryColor':'#E8F5E9','primaryTextColor':'#1B5E20','primaryBorderColor':'#4CAF50','lineColor':'#66BB6A','secondaryColor':'#FFF3E0','tertiaryColor':'#E3F2FD','fontSize':'16px'}}}%%\ngraph TB\n    Root[\"&lt;b&gt;Financial Instruments&lt;/b&gt;&lt;br/&gt;16+ Instruments\"]\n\n    Equity[\"&lt;b&gt;\ud83d\udcc8 Equity&lt;/b&gt;&lt;br/&gt;8 Instruments&lt;br/&gt;&lt;i&gt;Options, Swaps, Futures&lt;/i&gt;\"]\n    Fixed[\"&lt;b&gt;\ud83d\udcb0 Fixed Income&lt;/b&gt;&lt;br/&gt;3 Instruments&lt;br/&gt;&lt;i&gt;Bonds, Notes&lt;/i&gt;\"]\n    Credit[\"&lt;b&gt;\ud83d\udee1\ufe0f Credit&lt;/b&gt;&lt;br/&gt;3 Instruments&lt;br/&gt;&lt;i&gt;CDS, Protection&lt;/i&gt;\"]\n    Rates[\"&lt;b&gt;\ud83d\udcca Interest Rates&lt;/b&gt;&lt;br/&gt;1 Instrument&lt;br/&gt;&lt;i&gt;Swaps&lt;/i&gt;\"]\n    FX[\"&lt;b&gt;\ud83d\udcb1 Foreign Exchange&lt;/b&gt;&lt;br/&gt;1 Instrument&lt;br/&gt;&lt;i&gt;Forwards&lt;/i&gt;\"]\n    CashFlow[\"&lt;b&gt;\ud83d\udcb5 Cash Flow&lt;/b&gt;&lt;br/&gt;4 Instruments&lt;br/&gt;&lt;i&gt;Performing, NPL&lt;/i&gt;\"]\n\n    Root --&gt; Equity\n    Root --&gt; Fixed\n    Root --&gt; Credit\n    Root --&gt; Rates\n    Root --&gt; FX\n    Root --&gt; CashFlow\n\n    Equity --&gt; EqOption[\"American/European Options&lt;br/&gt;Vanilla &amp; Exotic\"]\n    Equity --&gt; EqSwap[\"Equity Swaps&lt;br/&gt;Total Return\"]\n    Equity --&gt; EqFutures[\"Index Futures&lt;br/&gt;Forward Contracts\"]\n\n    Fixed --&gt; Treasury[\"Treasury Bonds&lt;br/&gt;Government Securities\"]\n    Fixed --&gt; Callable[\"Callable Bonds&lt;br/&gt;Embedded Options\"]\n    Fixed --&gt; FRN[\"Floating Rate Notes&lt;br/&gt;Variable Coupons\"]\n\n    Credit --&gt; CDS[\"Credit Default Swaps&lt;br/&gt;Single-Name Protection\"]\n    Credit --&gt; CDSIdx[\"CDS Indices&lt;br/&gt;Portfolio Protection\"]\n    Credit --&gt; CDXOpt[\"Index Options&lt;br/&gt;CDX/iTraxx\"]\n\n    Rates --&gt; IRS[\"Interest Rate Swaps&lt;br/&gt;Fixed vs Floating\"]\n\n    FX --&gt; FWD[\"Currency Forwards&lt;br/&gt;FX Hedging\"]\n\n    CashFlow --&gt; CF1[\"Non-Performing&lt;br/&gt;Distressed Assets\"]\n    CashFlow --&gt; CF2[\"Performing Fixed&lt;br/&gt;Fixed Rate CF\"]\n\n    style Root fill:#667eea,stroke:#764ba2,stroke-width:4px,color:#fff\n    style Equity fill:#E8F5E9,stroke:#4CAF50,stroke-width:3px,color:#1B5E20\n    style Fixed fill:#FFF3E0,stroke:#FF9800,stroke-width:3px,color:#E65100\n    style Credit fill:#FFEBEE,stroke:#F44336,stroke-width:3px,color:#C62828\n    style Rates fill:#F3E5F5,stroke:#9C27B0,stroke-width:3px,color:#6A1B9A\n    style FX fill:#E0F7FA,stroke:#00BCD4,stroke-width:3px,color:#006064\n    style CashFlow fill:#FFF9C4,stroke:#FFC107,stroke-width:3px,color:#F57F17\n\n    style EqOption fill:#C8E6C9,stroke:#4CAF50,stroke-width:2px\n    style EqSwap fill:#C8E6C9,stroke:#4CAF50,stroke-width:2px\n    style EqFutures fill:#C8E6C9,stroke:#4CAF50,stroke-width:2px\n\n    style Treasury fill:#FFE0B2,stroke:#FF9800,stroke-width:2px\n    style Callable fill:#FFE0B2,stroke:#FF9800,stroke-width:2px\n    style FRN fill:#FFE0B2,stroke:#FF9800,stroke-width:2px\n\n    style CDS fill:#FFCDD2,stroke:#F44336,stroke-width:2px\n    style CDSIdx fill:#FFCDD2,stroke:#F44336,stroke-width:2px\n    style CDXOpt fill:#FFCDD2,stroke:#F44336,stroke-width:2px\n\n    style IRS fill:#E1BEE7,stroke:#9C27B0,stroke-width:2px\n    style FWD fill:#B2EBF2,stroke:#00BCD4,stroke-width:2px\n    style CF1 fill:#FFF59D,stroke:#FFC107,stroke-width:2px\n    style CF2 fill:#FFF59D,stroke:#FFC107,stroke-width:2px</code></pre>  Interactive diagram showing all 16+ financial instruments organized by asset class"},{"location":"instruments/#common-attributes","title":"Common Attributes","text":"<p>All instruments share these common properties:</p> <ul> <li>Valuation Date: Current market date for pricing</li> <li>Market Data: Curves, volatilities, correlations</li> <li>Pricing Engine: Calculation methodology</li> <li>Calendar: Business day conventions</li> <li>Day Count Convention: Interest accrual method</li> </ul>"},{"location":"instruments/#quick-navigation","title":"Quick Navigation","text":"By Asset ClassBy ComplexityBy Pricing Method <ul> <li>Equity</li> <li>Fixed Income</li> <li>Credit</li> <li>Rates</li> <li>FX</li> </ul> <p>Basic: - European Options - Treasury Bonds - Currency Forwards</p> <p>Intermediate: - American Options - Floating Rate Notes - Interest Rate Swaps</p> <p>Advanced: - Credit Default Swaps - Callable Bonds - Equity Swaps</p> <p>Analytical: - Black-Scholes (European Options) - Black's Model (Swaptions)</p> <p>Numerical: - Binomial Trees (American Options) - Monte Carlo (Path-Dependent) - Finite Differences (PDEs)</p>"},{"location":"instruments/#example-usage","title":"Example Usage","text":"<pre><code>import QuantLib as ql\n\n# Common setup for all instruments\ncalculation_date = ql.Date(15, 1, 2025)\nql.Settings.instance().evaluationDate = calculation_date\n\n# Example 1: European Equity Option\noption = ql.VanillaOption(\n    ql.PlainVanillaPayoff(ql.Option.Call, 100.0),\n    ql.EuropeanExercise(ql.Date(15, 6, 2025))\n)\n\n# Example 2: Interest Rate Swap\nswap = ql.VanillaSwap(\n    ql.VanillaSwap.Payer,\n    1000000,  # Notional\n    fixed_schedule,\n    0.05,  # Fixed rate\n    ql.Actual360(),\n    float_schedule,\n    ql.Euribor6M(),\n    0.0,  # Spread\n    ql.Actual360()\n)\n\n# Example 3: Credit Default Swap\ncds = ql.CreditDefaultSwap(\n    ql.Protection.Buyer,\n    10000000,  # Notional\n    0.01,  # Spread\n    schedule,\n    ql.Following,\n    ql.Actual360()\n)\n</code></pre>"},{"location":"instruments/#see-also","title":"See Also","text":"<ul> <li>Getting Started Guide</li> <li>Pricing Examples</li> <li>API Reference</li> </ul>"},{"location":"instruments/cashflow/overview/","title":"overview","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/cashflow/overview/#overview_1","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/cashflow/overview/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/cashflow/overview/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/credit/cds/","title":"Credit Default Swap (CDS)","text":"<p>CREDIT</p> <p>Derivative contract providing protection against credit default events.</p>"},{"location":"instruments/credit/cds/#overview","title":"Overview","text":"<p>Class: <code>CreditDefaultSwap</code> Category: Credit Derivatives Type: Credit Protection</p> <p>A Credit Default Swap is a bilateral financial derivative contract where the buyer makes periodic premium payments to the seller in exchange for protection against a credit event (default, bankruptcy, restructuring) of a reference entity. If a credit event occurs, the seller compensates the buyer for the loss.</p>"},{"location":"instruments/credit/cds/#key-features","title":"\ud83d\udca1 Key Features","text":"<ul> <li>Credit Protection: Transfer credit risk without selling the underlying asset</li> <li>Premium Payments: Quarterly or semi-annual premium payments (spread)</li> <li>Credit Events: Default, bankruptcy, failure to pay, restructuring</li> <li>Settlement: Cash or physical settlement upon credit event</li> <li>ISDA Standard: Industry-standard documentation and pricing</li> </ul>"},{"location":"instruments/credit/cds/#python-class-implementation","title":"\ud83d\udcd0 Python Class Implementation","text":"<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import List, Optional\nfrom enum import Enum\nimport numpy as np\n\nclass CreditEvent(Enum):\n    \"\"\"Types of credit events\"\"\"\n    BANKRUPTCY = \"bankruptcy\"\n    FAILURE_TO_PAY = \"failure_to_pay\"\n    RESTRUCTURING = \"restructuring\"\n    DEFAULT = \"default\"\n\nclass SettlementType(Enum):\n    \"\"\"CDS settlement methods\"\"\"\n    CASH = \"cash\"\n    PHYSICAL = \"physical\"\n\n@dataclass\nclass PremiumPayment:\n    \"\"\"Single premium payment\"\"\"\n    payment_date: datetime\n    premium_amount: float\n    accrued_days: int\n    survival_probability: float = 1.0\n\n@dataclass\nclass CDSCashFlows:\n    \"\"\"All cash flows for a CDS\"\"\"\n    premium_leg: List[PremiumPayment]\n    protection_leg_pv: float\n    upfront_fee: float\n    total_pv: float\n\nclass CreditDefaultSwap:\n    \"\"\"\n    Complete implementation of a Credit Default Swap\n\n    Attributes:\n        notional: Notional amount of protection\n        spread: CDS spread in basis points (e.g., 100 for 100 bps = 1%)\n        recovery_rate: Expected recovery rate on default (typically 0.40 for senior unsecured)\n        start_date: Protection start date\n        maturity_date: Protection end date\n        payment_frequency: Premium payments per year (typically 4 for quarterly)\n        upfront_fee: Initial upfront payment (can be negative)\n        position: 'buyer' (protection buyer) or 'seller' (protection seller)\n    \"\"\"\n\n    def __init__(\n        self,\n        notional: float,\n        spread: float,  # In basis points\n        recovery_rate: float,\n        start_date: datetime,\n        maturity_date: datetime,\n        payment_frequency: int = 4,  # Quarterly\n        upfront_fee: float = 0.0,\n        position: str = \"buyer\"\n    ):\n        self.notional = notional\n        self.spread = spread / 10000.0  # Convert bps to decimal\n        self.recovery_rate = recovery_rate\n        self.start_date = start_date\n        self.maturity_date = maturity_date\n        self.payment_frequency = payment_frequency\n        self.upfront_fee = upfront_fee\n        self.position = position\n\n        # Validate\n        if position not in ['buyer', 'seller']:\n            raise ValueError(\"Position must be 'buyer' or 'seller'\")\n        if maturity_date &lt;= start_date:\n            raise ValueError(\"Maturity must be after start date\")\n        if recovery_rate &lt; 0 or recovery_rate &gt; 1:\n            raise ValueError(\"Recovery rate must be between 0 and 1\")\n        if notional &lt;= 0:\n            raise ValueError(\"Notional must be positive\")\n\n    def generate_payment_schedule(self) -&gt; List[datetime]:\n        \"\"\"\n        Generate premium payment dates (typically quarterly)\n\n        Returns:\n            List of payment dates\n        \"\"\"\n        schedule = []\n        current = self.start_date\n        months_per_payment = 12 // self.payment_frequency\n\n        while current &lt; self.maturity_date:\n            month = current.month + months_per_payment\n            year = current.year + (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n\n            # Standard CDS dates: 20th of month\n            try:\n                current = datetime(year, month, 20)\n            except ValueError:\n                current = datetime(year, month, 28)\n\n            if current &lt;= self.maturity_date:\n                schedule.append(current)\n\n        # Ensure maturity is included\n        if not schedule or schedule[-1] != self.maturity_date:\n            schedule.append(self.maturity_date)\n\n        return schedule\n\n    def calculate_hazard_rate(\n        self,\n        survival_probability: float,\n        time_years: float\n    ) -&gt; float:\n        \"\"\"\n        Calculate constant hazard rate from survival probability\n\n        Args:\n            survival_probability: Probability of no default\n            time_years: Time period in years\n\n        Returns:\n            Hazard rate (intensity)\n        \"\"\"\n        if survival_probability &lt;= 0 or survival_probability &gt; 1:\n            raise ValueError(\"Survival probability must be between 0 and 1\")\n\n        return -np.log(survival_probability) / time_years\n\n    def calculate_survival_probability(\n        self,\n        hazard_rate: float,\n        time_years: float\n    ) -&gt; float:\n        \"\"\"\n        Calculate survival probability from hazard rate\n\n        Args:\n            hazard_rate: Constant intensity\n            time_years: Time period in years\n\n        Returns:\n            Survival probability\n        \"\"\"\n        return np.exp(-hazard_rate * time_years)\n\n    def bootstrap_hazard_rate_from_spread(\n        self,\n        discount_rate: float = 0.05\n    ) -&gt; float:\n        \"\"\"\n        Bootstrap hazard rate from CDS spread (simplified)\n\n        Args:\n            discount_rate: Risk-free discount rate\n\n        Returns:\n            Bootstrapped hazard rate\n        \"\"\"\n        # Simplified approximation: spread \u2248 hazard_rate * (1 - recovery_rate)\n        hazard_rate = self.spread / (1 - self.recovery_rate)\n        return hazard_rate\n\n    def calculate_premium_leg_pv(\n        self,\n        hazard_rate: float,\n        discount_rate: float,\n        valuation_date: datetime = None\n    ) -&gt; tuple:\n        \"\"\"\n        Calculate present value of premium leg\n\n        Args:\n            hazard_rate: Credit intensity\n            discount_rate: Risk-free rate for discounting\n            valuation_date: Valuation date\n\n        Returns:\n            Tuple of (premium_leg_pv, premium_payments list)\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.start_date\n\n        schedule = self.generate_payment_schedule()\n        premium_payments = []\n        pv = 0.0\n        prev_date = self.start_date\n\n        for payment_date in schedule:\n            if payment_date &gt; valuation_date:\n                # Calculate period\n                period_days = (payment_date - prev_date).days\n                time_to_payment = (payment_date - valuation_date).days / 365.0\n\n                # Premium amount\n                premium = self.notional * self.spread * (period_days / 360.0)\n\n                # Survival probability to payment date\n                survival_prob = self.calculate_survival_probability(\n                    hazard_rate, time_to_payment\n                )\n\n                # Discount factor\n                discount_factor = np.exp(-discount_rate * time_to_payment)\n\n                # PV of this payment\n                pv += premium * survival_prob * discount_factor\n\n                premium_payments.append(PremiumPayment(\n                    payment_date=payment_date,\n                    premium_amount=premium,\n                    accrued_days=period_days,\n                    survival_probability=survival_prob\n                ))\n\n            prev_date = payment_date\n\n        return pv, premium_payments\n\n    def calculate_protection_leg_pv(\n        self,\n        hazard_rate: float,\n        discount_rate: float,\n        valuation_date: datetime = None,\n        num_steps: int = 365\n    ) -&gt; float:\n        \"\"\"\n        Calculate present value of protection leg using numerical integration\n\n        Args:\n            hazard_rate: Credit intensity\n            discount_rate: Risk-free rate\n            valuation_date: Valuation date\n            num_steps: Number of integration steps\n\n        Returns:\n            Protection leg present value\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.start_date\n\n        T = (self.maturity_date - valuation_date).days / 365.0\n        if T &lt;= 0:\n            return 0.0\n\n        dt = T / num_steps\n        protection_pv = 0.0\n\n        # Loss given default\n        lgd = 1 - self.recovery_rate\n\n        # Integrate over time: LGD * hazard_rate * survival(t) * discount(t) dt\n        for i in range(num_steps):\n            t = (i + 0.5) * dt  # Midpoint\n\n            survival_prob = self.calculate_survival_probability(hazard_rate, t)\n            discount_factor = np.exp(-discount_rate * t)\n\n            # Default probability density = hazard_rate * survival_prob\n            default_density = hazard_rate * survival_prob\n\n            protection_pv += lgd * default_density * discount_factor * dt\n\n        return self.notional * protection_pv\n\n    def calculate_fair_spread(\n        self,\n        hazard_rate: float,\n        discount_rate: float,\n        valuation_date: datetime = None\n    ) -&gt; float:\n        \"\"\"\n        Calculate fair CDS spread (market spread where PV = 0)\n\n        Args:\n            hazard_rate: Credit intensity\n            discount_rate: Risk-free rate\n            valuation_date: Valuation date\n\n        Returns:\n            Fair spread in basis points\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.start_date\n\n        # Calculate protection leg PV\n        protection_pv = self.calculate_protection_leg_pv(\n            hazard_rate, discount_rate, valuation_date\n        )\n\n        # Calculate risky annuity (PV01 of premium leg)\n        schedule = self.generate_payment_schedule()\n        risky_annuity = 0.0\n        prev_date = self.start_date\n\n        for payment_date in schedule:\n            if payment_date &gt; valuation_date:\n                period_days = (payment_date - prev_date).days\n                time_to_payment = (payment_date - valuation_date).days / 365.0\n\n                survival_prob = self.calculate_survival_probability(\n                    hazard_rate, time_to_payment\n                )\n                discount_factor = np.exp(-discount_rate * time_to_payment)\n\n                risky_annuity += (period_days / 360.0) * survival_prob * discount_factor\n\n            prev_date = payment_date\n\n        # Fair spread = protection_pv / (notional * risky_annuity)\n        fair_spread = protection_pv / (self.notional * risky_annuity)\n\n        return fair_spread * 10000  # Convert to basis points\n\n    def calculate_npv(\n        self,\n        market_spread: float,  # Current market spread in bps\n        discount_rate: float,\n        valuation_date: datetime = None\n    ) -&gt; float:\n        \"\"\"\n        Calculate mark-to-market value of CDS\n\n        Args:\n            market_spread: Current market CDS spread (bps)\n            discount_rate: Risk-free rate\n            valuation_date: Valuation date\n\n        Returns:\n            NPV of CDS (positive = gain for protection buyer)\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.start_date\n\n        # Bootstrap hazard rate from market spread\n        market_spread_decimal = market_spread / 10000.0\n        market_hazard_rate = market_spread_decimal / (1 - self.recovery_rate)\n\n        # Calculate protection leg PV\n        protection_pv = self.calculate_protection_leg_pv(\n            market_hazard_rate, discount_rate, valuation_date\n        )\n\n        # Calculate premium leg PV at contract spread\n        premium_pv, _ = self.calculate_premium_leg_pv(\n            market_hazard_rate, discount_rate, valuation_date\n        )\n\n        # NPV from protection buyer perspective\n        npv = protection_pv - premium_pv - self.upfront_fee\n\n        # Flip sign if protection seller\n        if self.position == \"seller\":\n            npv = -npv\n\n        return npv\n\n    def calculate_dv01(\n        self,\n        market_spread: float,\n        discount_rate: float,\n        valuation_date: datetime = None,\n        bump_size: float = 1.0  # 1 basis point\n    ) -&gt; float:\n        \"\"\"\n        Calculate DV01 (dollar value of 1 basis point)\n\n        Args:\n            market_spread: Current market spread (bps)\n            discount_rate: Risk-free rate\n            valuation_date: Valuation date\n            bump_size: Spread bump in bps\n\n        Returns:\n            Change in value for 1bp spread widening\n        \"\"\"\n        base_npv = self.calculate_npv(market_spread, discount_rate, valuation_date)\n        bumped_npv = self.calculate_npv(\n            market_spread + bump_size, discount_rate, valuation_date\n        )\n\n        return (bumped_npv - base_npv) / bump_size\n\n    def calculate_credit_spread_01(\n        self,\n        hazard_rate: float,\n        discount_rate: float,\n        valuation_date: datetime = None\n    ) -&gt; float:\n        \"\"\"\n        Calculate CS01 (sensitivity to 1bp change in credit spread)\n\n        Returns:\n            CS01 value\n        \"\"\"\n        fair_spread = self.calculate_fair_spread(\n            hazard_rate, discount_rate, valuation_date\n        )\n\n        # Bump hazard rate\n        bumped_hazard = (fair_spread + 1) / 10000.0 / (1 - self.recovery_rate)\n\n        bumped_spread = self.calculate_fair_spread(\n            bumped_hazard, discount_rate, valuation_date\n        )\n\n        return abs(bumped_spread - fair_spread)\n\n    def get_summary(self) -&gt; dict:\n        \"\"\"Get CDS summary information\"\"\"\n        tenor_years = (self.maturity_date - self.start_date).days / 365.0\n\n        return {\n            'instrument_type': 'Credit Default Swap',\n            'notional': f\"${self.notional:,.0f}\",\n            'spread': f\"{self.spread * 10000:.2f} bps\",\n            'recovery_rate': f\"{self.recovery_rate * 100:.1f}%\",\n            'start_date': self.start_date.strftime('%Y-%m-%d'),\n            'maturity': self.maturity_date.strftime('%Y-%m-%d'),\n            'tenor': f\"{tenor_years:.2f} years\",\n            'payment_frequency': f\"{self.payment_frequency}x per year\",\n            'position': self.position.capitalize(),\n            'upfront_fee': f\"${self.upfront_fee:,.2f}\"\n        }\n</code></pre>"},{"location":"instruments/credit/cds/#usage-examples","title":"\ud83d\udcca Usage Examples","text":""},{"location":"instruments/credit/cds/#example-1-create-a-5-year-cds","title":"Example 1: Create a 5-Year CDS","text":"<pre><code>from datetime import datetime\n\n# Create CDS on corporate reference entity\n# Notional: $10M, Spread: 250 bps, Recovery: 40%\ncds = CreditDefaultSwap(\n    notional=10_000_000,\n    spread=250,  # 250 basis points = 2.5%\n    recovery_rate=0.40,\n    start_date=datetime(2025, 1, 20),\n    maturity_date=datetime(2030, 1, 20),\n    payment_frequency=4,  # Quarterly\n    upfront_fee=0.0,\n    position=\"buyer\"  # Buying protection\n)\n\n# Get summary\nprint(\"CDS Summary:\")\nfor key, value in cds.get_summary().items():\n    print(f\"  {key}: {value}\")\n</code></pre> <p>Output: <pre><code>CDS Summary:\n  instrument_type: Credit Default Swap\n  notional: $10,000,000\n  spread: 250.00 bps\n  recovery_rate: 40.0%\n  start_date: 2025-01-20\n  maturity: 2030-01-20\n  tenor: 5.00 years\n  payment_frequency: 4x per year\n  position: Buyer\n  upfront_fee: $0.00\n</code></pre></p>"},{"location":"instruments/credit/cds/#example-2-calculate-fair-spread","title":"Example 2: Calculate Fair Spread","text":"<pre><code># Bootstrap hazard rate and calculate fair spread\nhazard_rate = cds.bootstrap_hazard_rate_from_spread(discount_rate=0.05)\nprint(f\"\\nBootstrapped Hazard Rate: {hazard_rate*100:.4f}% per year\")\n\n# Calculate fair spread\nfair_spread = cds.calculate_fair_spread(\n    hazard_rate=hazard_rate,\n    discount_rate=0.05,\n    valuation_date=datetime(2025, 1, 20)\n)\n\nprint(f\"Fair CDS Spread: {fair_spread:.2f} bps\")\n</code></pre>"},{"location":"instruments/credit/cds/#example-3-calculate-cds-valuation-mark-to-market","title":"Example 3: Calculate CDS Valuation (Mark-to-Market)","text":"<pre><code># Entered CDS at 250 bps, now market spread is 300 bps\n# (credit quality has deteriorated)\nvaluation_date = datetime(2025, 6, 20)\n\nnpv = cds.calculate_npv(\n    market_spread=300,  # Current market spread\n    discount_rate=0.05,\n    valuation_date=valuation_date\n)\n\nprint(f\"\\nCDS Mark-to-Market:\")\nprint(f\"  Contract Spread: 250 bps\")\nprint(f\"  Market Spread: 300 bps\")\nprint(f\"  NPV (Protection Buyer): ${npv:,.2f}\")\n\nif npv &gt; 0:\n    print(f\"  Status: In-the-money (spreads widened, protection more valuable)\")\nelse:\n    print(f\"  Status: Out-of-the-money\")\n</code></pre>"},{"location":"instruments/credit/cds/#example-4-risk-metrics-dv01","title":"Example 4: Risk Metrics (DV01)","text":"<pre><code># Calculate DV01 - sensitivity to 1bp spread change\ndv01 = cds.calculate_dv01(\n    market_spread=250,\n    discount_rate=0.05,\n    valuation_date=datetime(2025, 1, 20)\n)\n\nprint(f\"\\nRisk Metrics:\")\nprint(f\"  DV01: ${dv01:,.2f} per 1bp\")\nprint(f\"  10bp Spread Widening Impact: ${dv01 * 10:,.2f}\")\nprint(f\"  50bp Spread Widening Impact: ${dv01 * 50:,.2f}\")\n\n# Calculate for different notionals\nnotionals = [1_000_000, 5_000_000, 10_000_000, 50_000_000]\nprint(f\"\\n{'Notional':&lt;15} {'DV01':&lt;15} {'10bp Impact'}\")\nprint(\"-\" * 50)\nfor notional in notionals:\n    temp_cds = CreditDefaultSwap(\n        notional, 250, 0.40,\n        datetime(2025, 1, 20), datetime(2030, 1, 20)\n    )\n    dv01_temp = temp_cds.calculate_dv01(250, 0.05, datetime(2025, 1, 20))\n    print(f\"${notional:&gt;13,} ${dv01_temp:&gt;13,.2f} ${dv01_temp*10:&gt;13,.2f}\")\n</code></pre>"},{"location":"instruments/credit/cds/#example-5-premium-leg-cash-flows","title":"Example 5: Premium Leg Cash Flows","text":"<pre><code># Calculate premium payments\nhazard_rate = 0.04  # 4% annual hazard rate\npremium_pv, payments = cds.calculate_premium_leg_pv(\n    hazard_rate=hazard_rate,\n    discount_rate=0.05,\n    valuation_date=datetime(2025, 1, 20)\n)\n\nprint(\"\\nPremium Payment Schedule:\")\nprint(\"-\" * 80)\nprint(f\"{'Date':&lt;12} {'Premium':&lt;15} {'Survival Prob':&lt;15} {'PV Contribution'}\")\nprint(\"-\" * 80)\n\nfor payment in payments[:8]:  # Show first 8 payments\n    time_years = (payment.payment_date - datetime(2025, 1, 20)).days / 365.0\n    discount = np.exp(-0.05 * time_years)\n    pv_contrib = payment.premium_amount * payment.survival_probability * discount\n\n    print(f\"{payment.payment_date.strftime('%Y-%m-%d'):&lt;12} \"\n          f\"${payment.premium_amount:&gt;13,.2f} \"\n          f\"{payment.survival_probability:&gt;13.6f} \"\n          f\"${pv_contrib:&gt;13,.2f}\")\n\nprint(f\"\\nTotal Premium Leg PV: ${premium_pv:,.2f}\")\n</code></pre>"},{"location":"instruments/credit/cds/#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"instruments/credit/cds/#1-credit-hedging","title":"1. Credit Hedging","text":"<pre><code># Bank hedges $50M corporate loan exposure\nloan_notional = 50_000_000\nloan_spread = 300  # bps over risk-free\n\n# Buy CDS protection\nhedge_cds = CreditDefaultSwap(\n    notional=loan_notional,\n    spread=250,  # Pay 250 bps for protection\n    recovery_rate=0.40,\n    start_date=datetime(2025, 1, 20),\n    maturity_date=datetime(2030, 1, 20),\n    position=\"buyer\"\n)\n\nprint(\"Credit Hedge Position:\")\nprint(f\"  Loan Exposure: ${loan_notional:,.0f}\")\nprint(f\"  Loan Spread Earned: {loan_spread} bps\")\nprint(f\"  CDS Premium Paid: 250 bps\")\nprint(f\"  Net Spread: {loan_spread - 250} bps\")\nprint(f\"  Annual Net Income: ${loan_notional * (loan_spread - 250) / 10000:,.2f}\")\n</code></pre>"},{"location":"instruments/credit/cds/#2-credit-arbitrage","title":"2. Credit Arbitrage","text":"<pre><code># Long/short credit arbitrage\n# Long protection on company A (250 bps)\n# Short protection on company B (300 bps)\n\ncds_long = CreditDefaultSwap(10_000_000, 250, 0.40,\n                             datetime(2025, 1, 20), datetime(2030, 1, 20),\n                             position=\"buyer\")\n\ncds_short = CreditDefaultSwap(10_000_000, 300, 0.40,\n                              datetime(2025, 1, 20), datetime(2030, 1, 20),\n                              position=\"seller\")\n\n# Calculate combined P&amp;L if both spreads widen by 50 bps\nnpv_long = cds_long.calculate_npv(300, 0.05, datetime(2025, 1, 20))\nnpv_short = cds_short.calculate_npv(350, 0.05, datetime(2025, 1, 20))\n\nprint(\"Credit Arbitrage Position:\")\nprint(f\"  Long CDS A: ${npv_long:,.2f}\")\nprint(f\"  Short CDS B: ${npv_short:,.2f}\")\nprint(f\"  Combined P&amp;L: ${npv_long + npv_short:,.2f}\")\n</code></pre>"},{"location":"instruments/credit/cds/#3-credit-curve-trading","title":"3. Credit Curve Trading","text":"<pre><code># CDS curve: 1Y, 3Y, 5Y, 10Y\nmaturities = [1, 3, 5, 10]\nspreads = [100, 180, 250, 350]  # bps\n\nprint(\"CDS Curve:\")\nprint(f\"{'Tenor':&lt;10} {'Spread':&lt;12} {'Hazard Rate':&lt;15} {'Default Prob'}\")\nprint(\"-\" * 60)\n\nfor tenor, spread in zip(maturities, spreads):\n    maturity = datetime(2025 + tenor, 1, 20)\n    cds_temp = CreditDefaultSwap(\n        10_000_000, spread, 0.40,\n        datetime(2025, 1, 20), maturity\n    )\n    hazard = cds_temp.bootstrap_hazard_rate_from_spread(0.05)\n    default_prob = 1 - cds_temp.calculate_survival_probability(hazard, tenor)\n\n    print(f\"{tenor}Y{'':&lt;8} {spread:&gt;6} bps {hazard*100:&gt;11.4f}% {default_prob*100:&gt;11.2f}%\")\n</code></pre>"},{"location":"instruments/credit/cds/#advanced-pricing-with-quantlib","title":"\ud83d\udcc8 Advanced Pricing with QuantLib","text":"<pre><code>import QuantLib as ql\n\ndef price_cds_with_quantlib(\n    notional: float,\n    spread: float,  # in bps\n    recovery_rate: float,\n    start_date: datetime,\n    maturity_date: datetime,\n    hazard_rate: float,\n    discount_rate: float\n) -&gt; dict:\n    \"\"\"\n    Price CDS using QuantLib\n\n    Returns:\n        Dictionary with NPV, fair spread, DV01\n    \"\"\"\n    # Convert dates\n    ql_start = ql.Date(start_date.day, start_date.month, start_date.year)\n    ql_maturity = ql.Date(maturity_date.day, maturity_date.month, maturity_date.year)\n\n    # Set evaluation date\n    ql.Settings.instance().evaluationDate = ql_start\n\n    # Create schedule\n    schedule = ql.Schedule(\n        ql_start,\n        ql_maturity,\n        ql.Period(ql.Quarterly),\n        ql.NullCalendar(),\n        ql.Following,\n        ql.Unadjusted,\n        ql.DateGeneration.Forward,\n        False\n    )\n\n    # Create CDS\n    cds = ql.CreditDefaultSwap(\n        ql.Protection.Buyer,\n        notional,\n        spread / 10000.0,  # Convert bps to decimal\n        schedule,\n        ql.Following,\n        ql.Actual360()\n    )\n\n    # Create default probability term structure\n    hazard_curve = ql.FlatHazardRate(\n        ql_start,\n        hazard_rate,\n        ql.Actual365Fixed()\n    )\n\n    # Create discount curve\n    discount_curve = ql.FlatForward(\n        ql_start,\n        discount_rate,\n        ql.Actual365Fixed()\n    )\n\n    # Set pricing engine\n    engine = ql.MidPointCdsEngine(\n        ql.DefaultProbabilityTermStructureHandle(hazard_curve),\n        recovery_rate,\n        ql.YieldTermStructureHandle(discount_curve)\n    )\n\n    cds.setPricingEngine(engine)\n\n    return {\n        'npv': cds.NPV(),\n        'fair_spread': cds.fairSpread() * 10000,  # Convert to bps\n        'default_probability': 1 - hazard_curve.survivalProbability(ql_maturity)\n    }\n</code></pre>"},{"location":"instruments/credit/cds/#related-instruments","title":"\ud83d\udd17 Related Instruments","text":"<ul> <li>CDS Index - Portfolio of CDS contracts</li> <li>CDX/iTraxx Options - Options on CDS indices</li> <li>Total Return Swap - Alternative credit exposure</li> </ul>"},{"location":"instruments/credit/cds/#references","title":"\ud83d\udcda References","text":"<ul> <li>ISDA Documentation - CDS Standard Model</li> <li>O'Kane, D. (2008). Modelling Single-name and Multi-name Credit Derivatives</li> <li>QuantLib Credit Risk Documentation</li> </ul>"},{"location":"instruments/credit/cds/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<p>Counterparty Risk</p> <p>CDS contracts have significant counterparty risk - protection seller may default</p> <p>Wrong-Way Risk</p> <p>CDS value and counterparty credit quality may be correlated</p> <p>ISDA Standard</p> <p>Use ISDA standard model for pricing consistency with market</p> <p>Jump-to-Default Risk</p> <p>Sudden credit events can cause large losses for protection sellers</p> <p>Last Updated: 2025-01-17 | Version: 1.0 | Status: Production Ready</p>"},{"location":"instruments/credit/cds_index/","title":"cds index","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/credit/cds_index/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/credit/cds_index/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/credit/cds_index/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/credit/cdx_options/","title":"cdx options","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/credit/cdx_options/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/credit/cdx_options/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/credit/cdx_options/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/equity/american_option/","title":"Equity American Option","text":"<p>American-style equity options that can be exercised at any time before expiration.</p>"},{"location":"instruments/equity/american_option/#overview","title":"Overview","text":"<p>Class: <code>EquityAmericanOption</code> Category: Equity Exercise Style: American (early exercise allowed)</p> <p>An American option gives the holder the right, but not the obligation, to buy (call) or sell (put) an underlying asset at a predetermined strike price at any time up to and including the expiration date.</p>"},{"location":"instruments/equity/american_option/#features","title":"Features","text":"<ul> <li>Early exercise capability</li> <li>Path-dependent valuation</li> <li>Greeks calculation (Delta, Gamma, Vega, Theta, Rho)</li> <li>Multiple pricing methods available</li> </ul>"},{"location":"instruments/equity/american_option/#pricing-methods","title":"Pricing Methods","text":""},{"location":"instruments/equity/american_option/#1-binomial-tree","title":"1. Binomial Tree","text":"<p>The Cox-Ross-Rubinstein binomial tree model:</p> <pre><code>import QuantLib as ql\n\n# Market data\nspot = 100.0\nstrike = 105.0\nvolatility = 0.20\nrisk_free_rate = 0.05\ndividend_yield = 0.02\n\n# Dates\ncalculation_date = ql.Date(15, 1, 2025)\nmaturity_date = ql.Date(15, 6, 2025)\nql.Settings.instance().evaluationDate = calculation_date\n\n# Option setup\npayoff = ql.PlainVanillaPayoff(ql.Option.Call, strike)\nexercise = ql.AmericanExercise(calculation_date, maturity_date)\namerican_option = ql.VanillaOption(payoff, exercise)\n\n# Market data handles\nspot_handle = ql.QuoteHandle(ql.SimpleQuote(spot))\nflat_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, risk_free_rate, ql.Actual365Fixed())\n)\ndividend_ts = ql.YieldTermStructureHandle(\n    ql.FlatForward(calculation_date, dividend_yield, ql.Actual365Fixed())\n)\nflat_vol_ts = ql.BlackVolTermStructureHandle(\n    ql.BlackConstantVol(calculation_date, ql.NullCalendar(), volatility, ql.Actual365Fixed())\n)\n\n# Black-Scholes process\nbs_process = ql.BlackScholesMertonProcess(\n    spot_handle, dividend_ts, flat_ts, flat_vol_ts\n)\n\n# Binomial engine with 100 steps\nbinomial_engine = ql.BinomialVanillaEngine(bs_process, \"crr\", 100)\namerican_option.setPricingEngine(binomial_engine)\n\n# Results\nprint(f\"American Call Option Price: ${american_option.NPV():.2f}\")\nprint(f\"Delta: {american_option.delta():.4f}\")\nprint(f\"Gamma: {american_option.gamma():.4f}\")\nprint(f\"Vega: {american_option.vega():.4f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#2-finite-difference-method","title":"2. Finite Difference Method","text":"<p>For greater accuracy with complex payoffs:</p> <pre><code># Finite Difference engine\nfd_engine = ql.FdBlackScholesVanillaEngine(bs_process, 100, 100)\namerican_option.setPricingEngine(fd_engine)\n\nprint(f\"FD Price: ${american_option.NPV():.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#3-least-squares-monte-carlo-lsm","title":"3. Least Squares Monte Carlo (LSM)","text":"<p>For path-dependent features:</p> <pre><code># LSM Monte Carlo engine\nlsm_engine = ql.MCAmericanEngine(\n    bs_process,\n    \"PseudoRandom\",\n    timeSteps=100,\n    polynomOrder=2,\n    seedCalibration=42,\n    requiredSamples=10000\n)\namerican_option.setPricingEngine(lsm_engine)\n\nprint(f\"LSM MC Price: ${american_option.NPV():.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#greeks","title":"Greeks","text":"<p>The sensitivity measures (Greeks) help understand risk:</p> Greek Description Interpretation Delta \\(\\frac{\\partial V}{\\partial S}\\) Change in option value per $1 change in underlying Gamma \\(\\frac{\\partial^2 V}{\\partial S^2}\\) Rate of change of Delta Vega \\(\\frac{\\partial V}{\\partial \\sigma}\\) Sensitivity to volatility changes Theta \\(\\frac{\\partial V}{\\partial t}\\) Time decay Rho \\(\\frac{\\partial V}{\\partial r}\\) Sensitivity to interest rate changes"},{"location":"instruments/equity/american_option/#early-exercise-boundary","title":"Early Exercise Boundary","text":"<pre><code>graph LR\n    A[Stock Price Path] --&gt; B{Stock Price &gt; Boundary?}\n    B --&gt;|Yes| C[Exercise Option]\n    B --&gt;|No| D[Hold Option]\n    C --&gt; E[Immediate Payoff]\n    D --&gt; F[Continue Monitoring]\n    F --&gt; B</code></pre>"},{"location":"instruments/equity/american_option/#pricing-comparison","title":"Pricing Comparison","text":"<pre><code># Compare different methods\nmethods = {\n    \"Binomial (100 steps)\": ql.BinomialVanillaEngine(bs_process, \"crr\", 100),\n    \"Binomial (200 steps)\": ql.BinomialVanillaEngine(bs_process, \"crr\", 200),\n    \"Finite Difference\": ql.FdBlackScholesVanillaEngine(bs_process, 100, 100),\n}\n\nprint(\"\\nPricing Method Comparison:\")\nprint(\"-\" * 50)\nfor name, engine in methods.items():\n    american_option.setPricingEngine(engine)\n    print(f\"{name:25s}: ${american_option.NPV():8.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#early-exercise-premium","title":"Early Exercise Premium","text":"<p>The American option value can be decomposed as:</p> \\[ V_{American} = V_{European} + \\text{Early Exercise Premium} \\] <pre><code># Calculate early exercise premium\neuropean_exercise = ql.EuropeanExercise(maturity_date)\neuropean_option = ql.VanillaOption(payoff, european_exercise)\neuropean_option.setPricingEngine(ql.AnalyticEuropeanEngine(bs_process))\n\npremium = american_option.NPV() - european_option.NPV()\nprint(f\"\\nEarly Exercise Premium: ${premium:.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#use-cases","title":"Use Cases","text":""},{"location":"instruments/equity/american_option/#portfolio-hedging","title":"Portfolio Hedging","text":"<p>American puts provide flexible downside protection:</p> <pre><code># Protective put strategy\nput_payoff = ql.PlainVanillaPayoff(ql.Option.Put, strike)\nput_exercise = ql.AmericanExercise(calculation_date, maturity_date)\nprotective_put = ql.VanillaOption(put_payoff, put_exercise)\nprotective_put.setPricingEngine(binomial_engine)\n\nportfolio_value = spot + protective_put.NPV()\nprint(f\"Protected Portfolio Value: ${portfolio_value:.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#employee-stock-options","title":"Employee Stock Options","text":"<p>Modeling ESOs with vesting periods:</p> <pre><code># ESO with vesting\nvesting_date = ql.Date(15, 3, 2025)\neso_exercise = ql.AmericanExercise(vesting_date, maturity_date)\neso = ql.VanillaOption(payoff, eso_exercise)\neso.setPricingEngine(binomial_engine)\n\nprint(f\"ESO Value: ${eso.NPV():.2f}\")\n</code></pre>"},{"location":"instruments/equity/american_option/#parameters","title":"Parameters","text":"Parameter Type Description Example <code>underlying_price</code> float Current stock price 100.0 <code>strike_price</code> float Exercise price 105.0 <code>volatility</code> float Implied volatility 0.20 <code>risk_free_rate</code> float Risk-free interest rate 0.05 <code>dividend_yield</code> float Continuous dividend yield 0.02 <code>maturity_date</code> Date Expiration date 2025-06-15 <code>option_type</code> str \"Call\" or \"Put\" \"Call\""},{"location":"instruments/equity/american_option/#best-practices","title":"Best Practices","text":"<p>Convergence</p> <p>Use at least 100 time steps for binomial trees to ensure convergence</p> <p>Dividends</p> <p>American calls on non-dividend paying stocks should never be exercised early</p> <p>Computational Cost</p> <p>Finite difference methods are faster for single options, Monte Carlo for portfolios</p>"},{"location":"instruments/equity/american_option/#references","title":"References","text":"<ul> <li>European Option - Comparison with European-style</li> <li>Equity Warrants - Similar instrument with dilution</li> <li>Pricing Examples - Interactive notebook</li> </ul>"},{"location":"instruments/equity/american_option/#api-reference","title":"API Reference","text":"<pre><code>class EquityAmericanOption:\n    \"\"\"\n    American-style equity option with early exercise.\n\n    Attributes:\n        underlying: Underlying stock\n        strike: Exercise price\n        maturity: Expiration date\n        option_type: Call or Put\n\n    Methods:\n        price(): Calculate option value\n        greeks(): Return all Greeks\n        exercise_boundary(): Optimal exercise boundary\n    \"\"\"\n</code></pre>"},{"location":"instruments/equity/american_option/#see-also","title":"See Also","text":"<ul> <li>Black-Scholes Model</li> <li>Binomial Trees</li> <li>Monte Carlo Methods</li> </ul>"},{"location":"instruments/equity/american_warrant/","title":"american warrant","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/equity/american_warrant/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/equity/american_warrant/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/equity/american_warrant/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/equity/equity_index_swap/","title":"equity index swap","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/equity/equity_index_swap/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/equity/equity_index_swap/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/equity/equity_index_swap/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/equity/equity_swap/","title":"Equity Swap","text":"<p>EQUITY</p> <p>Exchange of cash flows where at least one leg is based on equity returns.</p>"},{"location":"instruments/equity/equity_swap/#overview","title":"Overview","text":"<p>Class: <code>EquitySwap</code> Category: Equity Type: Total Return Swap</p> <p>An equity swap is a bilateral financial derivative contract where two parties agree to exchange sets of future cash flows. Typically, one leg is based on the total return (price appreciation plus dividends) of an equity or equity index, while the other leg is a fixed or floating rate.</p>"},{"location":"instruments/equity/equity_swap/#key-features","title":"\ud83d\udca1 Key Features","text":"<ul> <li>Total Return Exchange: Combines price appreciation and dividend payments</li> <li>Leverage: Gain equity exposure without owning the underlying</li> <li>Customizable: Flexible notional amounts and payment schedules</li> <li>Hedging: Effective tool for managing equity risk</li> </ul>"},{"location":"instruments/equity/equity_swap/#python-class-implementation","title":"\ud83d\udcd0 Python Class Implementation","text":"<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom enum import Enum\nfrom typing import List, Optional\nimport QuantLib as ql\n\nclass SwapLegType(Enum):\n    \"\"\"Type of swap leg\"\"\"\n    EQUITY_RETURN = \"equity_return\"\n    FIXED_RATE = \"fixed_rate\"\n    FLOATING_RATE = \"floating_rate\"\n\n@dataclass\nclass EquityLeg:\n    \"\"\"Equity leg of the swap\"\"\"\n    underlying_ticker: str\n    initial_price: float\n    notional: float\n    dividend_yield: float = 0.0\n\n    def calculate_return(self, final_price: float,\n                        period_days: int) -&gt; float:\n        \"\"\"\n        Calculate total return including price appreciation and dividends\n\n        Args:\n            final_price: Final price of underlying\n            period_days: Number of days in period\n\n        Returns:\n            Total return amount\n        \"\"\"\n        # Price return\n        price_return = (final_price - self.initial_price) / self.initial_price\n\n        # Dividend return (assuming continuous compounding)\n        dividend_return = self.dividend_yield * (period_days / 365.0)\n\n        # Total return\n        total_return = price_return + dividend_return\n\n        return self.notional * total_return\n\n@dataclass\nclass FixedLeg:\n    \"\"\"Fixed rate leg of the swap\"\"\"\n    notional: float\n    fixed_rate: float\n    day_count: str = \"ACT/360\"\n\n    def calculate_payment(self, period_days: int) -&gt; float:\n        \"\"\"\n        Calculate fixed payment\n\n        Args:\n            period_days: Number of days in period\n\n        Returns:\n            Fixed payment amount\n        \"\"\"\n        if self.day_count == \"ACT/360\":\n            year_fraction = period_days / 360.0\n        elif self.day_count == \"ACT/365\":\n            year_fraction = period_days / 365.0\n        else:  # 30/360\n            year_fraction = period_days / 360.0\n\n        return self.notional * self.fixed_rate * year_fraction\n\nclass EquitySwap:\n    \"\"\"\n    Complete implementation of an Equity Total Return Swap\n\n    Attributes:\n        equity_leg: Equity return leg\n        fixed_leg: Fixed rate leg\n        start_date: Swap start date\n        maturity_date: Swap maturity date\n        payment_frequency: Payments per year\n        position: 'payer' or 'receiver' of equity returns\n    \"\"\"\n\n    def __init__(\n        self,\n        equity_leg: EquityLeg,\n        fixed_leg: FixedLeg,\n        start_date: datetime,\n        maturity_date: datetime,\n        payment_frequency: int = 4,  # Quarterly\n        position: str = \"payer\"\n    ):\n        self.equity_leg = equity_leg\n        self.fixed_leg = fixed_leg\n        self.start_date = start_date\n        self.maturity_date = maturity_date\n        self.payment_frequency = payment_frequency\n        self.position = position  # 'payer' pays equity, receives fixed\n\n        # Validate\n        if position not in ['payer', 'receiver']:\n            raise ValueError(\"Position must be 'payer' or 'receiver'\")\n\n        if maturity_date &lt;= start_date:\n            raise ValueError(\"Maturity must be after start date\")\n\n    def generate_payment_schedule(self) -&gt; List[datetime]:\n        \"\"\"\n        Generate payment dates based on frequency\n\n        Returns:\n            List of payment dates\n        \"\"\"\n        schedule = []\n        current = self.start_date\n        months_per_payment = 12 // self.payment_frequency\n\n        while current &lt; self.maturity_date:\n            # Add months\n            month = current.month + months_per_payment\n            year = current.year + (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n\n            current = datetime(year, month, current.day)\n            if current &lt;= self.maturity_date:\n                schedule.append(current)\n\n        # Ensure maturity is included\n        if schedule[-1] != self.maturity_date:\n            schedule.append(self.maturity_date)\n\n        return schedule\n\n    def calculate_cash_flows(\n        self,\n        equity_prices: List[float],\n        valuation_date: datetime = None\n    ) -&gt; dict:\n        \"\"\"\n        Calculate all cash flows for the swap\n\n        Args:\n            equity_prices: List of equity prices at each payment date\n            valuation_date: Date for NPV calculation\n\n        Returns:\n            Dictionary with cash flow details\n        \"\"\"\n        schedule = self.generate_payment_schedule()\n\n        if len(equity_prices) != len(schedule):\n            raise ValueError(\n                f\"Need {len(schedule)} prices for {len(schedule)} payments\"\n            )\n\n        cash_flows = []\n        prev_price = self.equity_leg.initial_price\n\n        for i, (date, price) in enumerate(zip(schedule, equity_prices)):\n            # Calculate period days\n            if i == 0:\n                period_days = (date - self.start_date).days\n            else:\n                period_days = (date - schedule[i-1]).days\n\n            # Equity leg payment\n            equity_payment = self.equity_leg.calculate_return(\n                price, period_days\n            )\n\n            # Fixed leg payment\n            fixed_payment = self.fixed_leg.calculate_payment(period_days)\n\n            # Net cash flow (from payer perspective)\n            if self.position == \"payer\":\n                net_cf = fixed_payment - equity_payment\n            else:\n                net_cf = equity_payment - fixed_payment\n\n            cash_flows.append({\n                'date': date,\n                'equity_price': price,\n                'equity_payment': equity_payment,\n                'fixed_payment': fixed_payment,\n                'net_cash_flow': net_cf,\n                'period_days': period_days\n            })\n\n            prev_price = price\n\n        return {\n            'cash_flows': cash_flows,\n            'total_equity_payments': sum(cf['equity_payment']\n                                        for cf in cash_flows),\n            'total_fixed_payments': sum(cf['fixed_payment']\n                                       for cf in cash_flows),\n            'total_net_cash_flow': sum(cf['net_cash_flow']\n                                      for cf in cash_flows)\n        }\n\n    def calculate_npv(\n        self,\n        equity_prices: List[float],\n        discount_rate: float,\n        valuation_date: datetime = None\n    ) -&gt; float:\n        \"\"\"\n        Calculate Net Present Value of the swap\n\n        Args:\n            equity_prices: Projected equity prices\n            discount_rate: Discount rate for NPV\n            valuation_date: Valuation date (default: start_date)\n\n        Returns:\n            NPV of the swap\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.start_date\n\n        result = self.calculate_cash_flows(equity_prices, valuation_date)\n        npv = 0.0\n\n        for cf in result['cash_flows']:\n            days_to_payment = (cf['date'] - valuation_date).days\n            discount_factor = 1 / (1 + discount_rate) ** (days_to_payment / 365.0)\n            npv += cf['net_cash_flow'] * discount_factor\n\n        return npv\n\n    def get_summary(self) -&gt; dict:\n        \"\"\"Get swap summary information\"\"\"\n        return {\n            'instrument_type': 'Equity Swap',\n            'underlying': self.equity_leg.underlying_ticker,\n            'notional': self.equity_leg.notional,\n            'fixed_rate': f\"{self.fixed_leg.fixed_rate * 100:.2f}%\",\n            'start_date': self.start_date.strftime('%Y-%m-%d'),\n            'maturity': self.maturity_date.strftime('%Y-%m-%d'),\n            'frequency': f\"{self.payment_frequency}x per year\",\n            'position': self.position,\n            'tenor_days': (self.maturity_date - self.start_date).days\n        }\n</code></pre>"},{"location":"instruments/equity/equity_swap/#usage-examples","title":"\ud83d\udcca Usage Examples","text":""},{"location":"instruments/equity/equity_swap/#example-1-basic-equity-swap","title":"Example 1: Basic Equity Swap","text":"<pre><code>from datetime import datetime, timedelta\n\n# Set up equity leg\nequity_leg = EquityLeg(\n    underlying_ticker=\"SPY\",\n    initial_price=450.00,\n    notional=10_000_000,  # $10M\n    dividend_yield=0.015  # 1.5% annual dividend yield\n)\n\n# Set up fixed leg\nfixed_leg = FixedLeg(\n    notional=10_000_000,\n    fixed_rate=0.05,  # 5% annual\n    day_count=\"ACT/360\"\n)\n\n# Create swap\nswap = EquitySwap(\n    equity_leg=equity_leg,\n    fixed_leg=fixed_leg,\n    start_date=datetime(2025, 1, 15),\n    maturity_date=datetime(2026, 1, 15),\n    payment_frequency=4,  # Quarterly payments\n    position=\"payer\"  # Pay equity, receive fixed\n)\n\n# Get summary\nprint(\"Swap Summary:\")\nfor key, value in swap.get_summary().items():\n    print(f\"  {key}: {value}\")\n</code></pre> <p>Output: <pre><code>Swap Summary:\n  instrument_type: Equity Swap\n  underlying: SPY\n  notional: 10000000\n  fixed_rate: 5.00%\n  start_date: 2025-01-15\n  maturity: 2026-01-15\n  frequency: 4x per year\n  position: payer\n  tenor_days: 365\n</code></pre></p>"},{"location":"instruments/equity/equity_swap/#example-2-calculate-cash-flows","title":"Example 2: Calculate Cash Flows","text":"<pre><code># Projected SPY prices at each quarterly payment\nprojected_prices = [\n    460.00,  # Q1: +2.22%\n    465.00,  # Q2: +1.09%\n    470.00,  # Q3: +1.08%\n    480.00   # Q4: +2.13%\n]\n\n# Calculate all cash flows\nresult = swap.calculate_cash_flows(projected_prices)\n\nprint(\"\\nCash Flow Schedule:\")\nprint(\"-\" * 80)\nfor cf in result['cash_flows']:\n    print(f\"Date: {cf['date'].strftime('%Y-%m-%d')}\")\n    print(f\"  Equity Price: ${cf['equity_price']:.2f}\")\n    print(f\"  Equity Payment: ${cf['equity_payment']:,.2f}\")\n    print(f\"  Fixed Payment: ${cf['fixed_payment']:,.2f}\")\n    print(f\"  Net Cash Flow: ${cf['net_cash_flow']:,.2f}\")\n    print()\n\nprint(f\"Total Equity Payments: ${result['total_equity_payments']:,.2f}\")\nprint(f\"Total Fixed Payments: ${result['total_fixed_payments']:,.2f}\")\nprint(f\"Total Net Cash Flow: ${result['total_net_cash_flow']:,.2f}\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#example-3-npv-calculation","title":"Example 3: NPV Calculation","text":"<pre><code># Calculate NPV with 4% discount rate\nnpv = swap.calculate_npv(\n    equity_prices=projected_prices,\n    discount_rate=0.04,\n    valuation_date=datetime(2025, 1, 15)\n)\n\nprint(f\"\\nSwap NPV: ${npv:,.2f}\")\n\n# Sensitivity analysis\ndiscount_rates = [0.03, 0.04, 0.05, 0.06]\nprint(\"\\nNPV Sensitivity to Discount Rate:\")\nfor rate in discount_rates:\n    npv = swap.calculate_npv(projected_prices, rate)\n    print(f\"  {rate*100:.1f}%: ${npv:,.2f}\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"instruments/equity/equity_swap/#1-synthetic-equity-position","title":"1. Synthetic Equity Position","text":"<pre><code># Investor wants S&amp;P 500 exposure without buying shares\n# Uses equity swap to gain exposure while paying LIBOR + spread\n\nsynthetic_exposure = EquitySwap(\n    equity_leg=EquityLeg(\"SPX\", 4500.0, 50_000_000, 0.0175),\n    fixed_leg=FixedLeg(50_000_000, 0.0525),  # LIBOR + 25bps\n    start_date=datetime.now(),\n    maturity_date=datetime.now() + timedelta(days=365),\n    payment_frequency=4,\n    position=\"receiver\"  # Receive equity returns\n)\n\nprint(\"Synthetic long position created\")\nprint(f\"Exposure: ${synthetic_exposure.equity_leg.notional:,.0f}\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#2-portfolio-hedging","title":"2. Portfolio Hedging","text":"<pre><code># Fund manager hedges $100M equity portfolio\nhedge_swap = EquitySwap(\n    equity_leg=EquityLeg(\"Portfolio\", 100.0, 100_000_000, 0.02),\n    fixed_leg=FixedLeg(100_000_000, 0.045),\n    start_date=datetime(2025, 1, 1),\n    maturity_date=datetime(2025, 12, 31),\n    payment_frequency=2,  # Semi-annual\n    position=\"payer\"  # Pay equity returns (short position)\n)\n\nprint(\"Portfolio hedge established\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#pricing-methods","title":"\ud83d\udcc8 Pricing Methods","text":""},{"location":"instruments/equity/equity_swap/#monte-carlo-simulation","title":"Monte Carlo Simulation","text":"<p>For path-dependent features or complex payoffs:</p> <pre><code>import numpy as np\n\ndef monte_carlo_equity_swap_pricing(\n    swap: EquitySwap,\n    spot_price: float,\n    volatility: float,\n    num_simulations: int = 10000\n) -&gt; dict:\n    \"\"\"\n    Price equity swap using Monte Carlo\n\n    Returns:\n        Dict with NPV statistics\n    \"\"\"\n    np.random.seed(42)\n    schedule = swap.generate_payment_schedule()\n    dt = 1/swap.payment_frequency\n\n    npvs = []\n\n    for _ in range(num_simulations):\n        prices = [spot_price]\n\n        for _ in range(len(schedule)):\n            # Geometric Brownian Motion\n            dW = np.random.normal(0, np.sqrt(dt))\n            next_price = prices[-1] * np.exp(\n                (0.05 - 0.5 * volatility**2) * dt +\n                volatility * dW\n            )\n            prices.append(next_price)\n\n        prices = prices[1:]  # Remove initial price\n        npv = swap.calculate_npv(prices, 0.04)\n        npvs.append(npv)\n\n    return {\n        'mean_npv': np.mean(npvs),\n        'std_npv': np.std(npvs),\n        'confidence_95': (\n            np.percentile(npvs, 2.5),\n            np.percentile(npvs, 97.5)\n        )\n    }\n\n# Example usage\nmc_result = monte_carlo_equity_swap_pricing(swap, 450.0, 0.20)\nprint(f\"\\nMonte Carlo NPV: ${mc_result['mean_npv']:,.2f}\")\nprint(f\"Std Dev: ${mc_result['std_npv']:,.2f}\")\nprint(f\"95% CI: ${mc_result['confidence_95'][0]:,.2f} to \"\n      f\"${mc_result['confidence_95'][1]:,.2f}\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#risk-metrics","title":"\ud83d\udcca Risk Metrics","text":""},{"location":"instruments/equity/equity_swap/#greeks-calculation","title":"Greeks Calculation","text":"<pre><code>def calculate_swap_delta(\n    swap: EquitySwap,\n    current_price: float,\n    projected_prices: List[float],\n    bump_size: float = 0.01  # 1% bump\n) -&gt; float:\n    \"\"\"\n    Calculate swap delta (sensitivity to spot price)\n    \"\"\"\n    # Base NPV\n    base_npv = swap.calculate_npv(projected_prices, 0.04)\n\n    # Bump prices\n    bumped_prices = [p * (1 + bump_size) for p in projected_prices]\n    bumped_npv = swap.calculate_npv(bumped_prices, 0.04)\n\n    # Delta\n    delta = (bumped_npv - base_npv) / (current_price * bump_size)\n\n    return delta\n\ndelta = calculate_swap_delta(swap, 450.0, projected_prices)\nprint(f\"\\nSwap Delta: {delta:,.2f}\")\nprint(f\"For 1% move in underlying: ${delta * 4.50:,.2f} P&amp;L impact\")\n</code></pre>"},{"location":"instruments/equity/equity_swap/#related-instruments","title":"\ud83d\udd17 Related Instruments","text":"<ul> <li>Equity Index Swap - Swap on equity index</li> <li>Interest Rate Swap - Rate swaps comparison</li> <li>Total Return Swap - General TRS documentation</li> </ul>"},{"location":"instruments/equity/equity_swap/#references","title":"\ud83d\udcda References","text":"<ul> <li>Hull, J. C. (2018). Options, Futures, and Other Derivatives</li> <li>ISDA Documentation - Equity Derivatives</li> <li>QuantLib Documentation</li> </ul>"},{"location":"instruments/equity/equity_swap/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<p>Mark-to-Market Risk</p> <p>Equity swaps require daily marking-to-market and may trigger margin calls</p> <p>Tax Considerations</p> <p>Tax treatment varies by jurisdiction - consult tax advisors</p> <p>Counterparty Risk</p> <p>Consider credit risk of the counterparty when entering swaps</p> <p>Last Updated: 2025-01-17 | Version: 1.0 | Status: Production Ready</p>"},{"location":"instruments/equity/european_option/","title":"european option","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/equity/european_option/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/equity/european_option/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/equity/european_option/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/equity/index_futures/","title":"index futures","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/equity/index_futures/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/equity/index_futures/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/equity/index_futures/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/fixed_income/callable_bond/","title":"callable bond","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/fixed_income/callable_bond/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/fixed_income/callable_bond/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/fixed_income/callable_bond/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/fixed_income/frn/","title":"frn","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/fixed_income/frn/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/fixed_income/frn/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/fixed_income/frn/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/","title":"Treasury Bond","text":"<p>FIXED INCOME</p> <p>Government-issued debt security with fixed coupon payments and principal repayment at maturity.</p>"},{"location":"instruments/fixed_income/treasury_bond/#overview","title":"Overview","text":"<p>Class: <code>TreasuryBond</code> Category: Fixed Income Type: Government Bond</p> <p>A Treasury Bond is a debt security issued by a government to finance spending. It pays a fixed coupon (interest) semi-annually and returns the face value at maturity. Treasury bonds are considered risk-free investments in their home currency and serve as benchmarks for other interest rates.</p>"},{"location":"instruments/fixed_income/treasury_bond/#key-features","title":"\ud83d\udca1 Key Features","text":"<ul> <li>Risk-Free Rate: Government-backed, considered default risk-free</li> <li>Fixed Coupon: Regular semi-annual interest payments</li> <li>Benchmark: Used to construct yield curves for pricing other instruments</li> <li>Liquidity: Highly liquid secondary market</li> <li>Maturity Range: Typically 10-30 years</li> </ul>"},{"location":"instruments/fixed_income/treasury_bond/#python-class-implementation","title":"\ud83d\udcd0 Python Class Implementation","text":"<pre><code>from dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import List, Optional\nimport QuantLib as ql\nfrom enum import Enum\n\nclass DayCountConvention(Enum):\n    \"\"\"Day count conventions for bond calculations\"\"\"\n    ACT_ACT = \"ACT/ACT\"\n    ACT_365 = \"ACT/365\"\n    ACT_360 = \"ACT/360\"\n    THIRTY_360 = \"30/360\"\n\nclass CompoundingFrequency(Enum):\n    \"\"\"Compounding frequency for yield calculations\"\"\"\n    ANNUAL = 1\n    SEMI_ANNUAL = 2\n    QUARTERLY = 4\n    MONTHLY = 12\n    CONTINUOUS = -1\n\n@dataclass\nclass CouponPayment:\n    \"\"\"Represents a single coupon payment\"\"\"\n    payment_date: datetime\n    coupon_amount: float\n    accrued_days: int\n    discount_factor: float = 1.0\n\n@dataclass\nclass BondCashFlows:\n    \"\"\"All cash flows for a treasury bond\"\"\"\n    coupon_payments: List[CouponPayment]\n    principal_payment: float\n    maturity_date: datetime\n    total_present_value: float\n\nclass TreasuryBond:\n    \"\"\"\n    Complete implementation of a Treasury Bond\n\n    Attributes:\n        face_value: Par value of the bond (typically 1000 or 100)\n        coupon_rate: Annual coupon rate (e.g., 0.05 for 5%)\n        issue_date: Date bond was issued\n        maturity_date: Date bond matures\n        payment_frequency: Payments per year (typically 2 for semi-annual)\n        day_count: Day count convention (typically ACT/ACT for US Treasury)\n    \"\"\"\n\n    def __init__(\n        self,\n        face_value: float,\n        coupon_rate: float,\n        issue_date: datetime,\n        maturity_date: datetime,\n        payment_frequency: int = 2,  # Semi-annual\n        day_count: str = \"ACT/ACT\"\n    ):\n        self.face_value = face_value\n        self.coupon_rate = coupon_rate\n        self.issue_date = issue_date\n        self.maturity_date = maturity_date\n        self.payment_frequency = payment_frequency\n        self.day_count = day_count\n\n        # Validate inputs\n        if maturity_date &lt;= issue_date:\n            raise ValueError(\"Maturity date must be after issue date\")\n        if coupon_rate &lt; 0:\n            raise ValueError(\"Coupon rate must be non-negative\")\n        if face_value &lt;= 0:\n            raise ValueError(\"Face value must be positive\")\n\n    def generate_coupon_schedule(self) -&gt; List[datetime]:\n        \"\"\"\n        Generate coupon payment dates\n\n        Returns:\n            List of payment dates\n        \"\"\"\n        schedule = []\n        current = self.issue_date\n        months_per_payment = 12 // self.payment_frequency\n\n        while current &lt; self.maturity_date:\n            # Add months\n            month = current.month + months_per_payment\n            year = current.year + (month - 1) // 12\n            month = ((month - 1) % 12) + 1\n\n            # Handle day overflow (e.g., Jan 31 -&gt; Feb 28)\n            try:\n                current = datetime(year, month, current.day)\n            except ValueError:\n                # Day doesn't exist in this month, use last day\n                if month == 2:\n                    day = 29 if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0) else 28\n                else:\n                    day = 30\n                current = datetime(year, month, day)\n\n            if current &lt;= self.maturity_date:\n                schedule.append(current)\n\n        # Ensure maturity date is included\n        if not schedule or schedule[-1] != self.maturity_date:\n            schedule.append(self.maturity_date)\n\n        return schedule\n\n    def calculate_coupon_payment(self, period_days: int) -&gt; float:\n        \"\"\"\n        Calculate single coupon payment\n\n        Args:\n            period_days: Days in the coupon period\n\n        Returns:\n            Coupon payment amount\n        \"\"\"\n        if self.day_count == \"ACT/ACT\":\n            year_fraction = period_days / 365.0\n        elif self.day_count == \"ACT/365\":\n            year_fraction = period_days / 365.0\n        elif self.day_count == \"ACT/360\":\n            year_fraction = period_days / 360.0\n        else:  # 30/360\n            year_fraction = period_days / 360.0\n\n        return self.face_value * self.coupon_rate * year_fraction\n\n    def calculate_cash_flows(\n        self,\n        valuation_date: datetime = None\n    ) -&gt; BondCashFlows:\n        \"\"\"\n        Calculate all future cash flows\n\n        Args:\n            valuation_date: Date for valuation (default: issue_date)\n\n        Returns:\n            BondCashFlows object with all payment details\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.issue_date\n\n        schedule = self.generate_coupon_schedule()\n        coupon_payments = []\n        prev_date = self.issue_date\n\n        for payment_date in schedule:\n            if payment_date &gt; valuation_date:\n                period_days = (payment_date - prev_date).days\n                coupon_amount = self.calculate_coupon_payment(period_days)\n\n                coupon_payments.append(CouponPayment(\n                    payment_date=payment_date,\n                    coupon_amount=coupon_amount,\n                    accrued_days=period_days\n                ))\n\n            prev_date = payment_date\n\n        return BondCashFlows(\n            coupon_payments=coupon_payments,\n            principal_payment=self.face_value,\n            maturity_date=self.maturity_date,\n            total_present_value=0.0  # Will be calculated in price method\n        )\n\n    def calculate_price(\n        self,\n        yield_to_maturity: float,\n        valuation_date: datetime = None,\n        compounding: int = 2\n    ) -&gt; float:\n        \"\"\"\n        Calculate bond price given yield\n\n        Args:\n            yield_to_maturity: YTM as decimal (e.g., 0.05 for 5%)\n            valuation_date: Valuation date\n            compounding: Compounding frequency (default: 2 for semi-annual)\n\n        Returns:\n            Bond price\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.issue_date\n\n        cash_flows = self.calculate_cash_flows(valuation_date)\n        price = 0.0\n\n        # Discount coupon payments\n        for cf in cash_flows.coupon_payments:\n            days_to_payment = (cf.payment_date - valuation_date).days\n            years = days_to_payment / 365.0\n            discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (years * compounding))\n            price += cf.coupon_amount * discount_factor\n\n        # Discount principal\n        days_to_maturity = (self.maturity_date - valuation_date).days\n        years = days_to_maturity / 365.0\n        discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (years * compounding))\n        price += self.face_value * discount_factor\n\n        return price\n\n    def calculate_yield(\n        self,\n        market_price: float,\n        valuation_date: datetime = None,\n        compounding: int = 2,\n        tolerance: float = 1e-6,\n        max_iterations: int = 100\n    ) -&gt; float:\n        \"\"\"\n        Calculate yield to maturity given market price (using Newton-Raphson)\n\n        Args:\n            market_price: Current market price of the bond\n            valuation_date: Valuation date\n            compounding: Compounding frequency\n            tolerance: Convergence tolerance\n            max_iterations: Maximum iterations\n\n        Returns:\n            Yield to maturity\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.issue_date\n\n        # Initial guess based on current yield\n        ytm = self.coupon_rate\n\n        for _ in range(max_iterations):\n            price = self.calculate_price(ytm, valuation_date, compounding)\n            diff = price - market_price\n\n            if abs(diff) &lt; tolerance:\n                return ytm\n\n            # Calculate derivative (duration approximation)\n            delta_y = 0.0001\n            price_up = self.calculate_price(ytm + delta_y, valuation_date, compounding)\n            derivative = (price_up - price) / delta_y\n\n            # Newton-Raphson update\n            ytm = ytm - diff / derivative\n\n        raise ValueError(\"Yield calculation did not converge\")\n\n    def calculate_duration(\n        self,\n        yield_to_maturity: float,\n        valuation_date: datetime = None,\n        compounding: int = 2\n    ) -&gt; dict:\n        \"\"\"\n        Calculate Macaulay and Modified duration\n\n        Returns:\n            Dictionary with duration metrics\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.issue_date\n\n        cash_flows = self.calculate_cash_flows(valuation_date)\n        price = self.calculate_price(yield_to_maturity, valuation_date, compounding)\n\n        weighted_time = 0.0\n\n        # Weight coupon payments by time\n        for cf in cash_flows.coupon_payments:\n            days_to_payment = (cf.payment_date - valuation_date).days\n            years = days_to_payment / 365.0\n            discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (years * compounding))\n            pv = cf.coupon_amount * discount_factor\n            weighted_time += years * pv\n\n        # Weight principal payment\n        days_to_maturity = (self.maturity_date - valuation_date).days\n        years = days_to_maturity / 365.0\n        discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (years * compounding))\n        pv = self.face_value * discount_factor\n        weighted_time += years * pv\n\n        macaulay_duration = weighted_time / price\n        modified_duration = macaulay_duration / (1 + yield_to_maturity / compounding)\n\n        return {\n            'macaulay_duration': macaulay_duration,\n            'modified_duration': modified_duration,\n            'price_sensitivity': -modified_duration * price  # Dollar duration\n        }\n\n    def calculate_convexity(\n        self,\n        yield_to_maturity: float,\n        valuation_date: datetime = None,\n        compounding: int = 2\n    ) -&gt; float:\n        \"\"\"\n        Calculate bond convexity\n\n        Returns:\n            Convexity value\n        \"\"\"\n        if valuation_date is None:\n            valuation_date = self.issue_date\n\n        price = self.calculate_price(yield_to_maturity, valuation_date, compounding)\n        cash_flows = self.calculate_cash_flows(valuation_date)\n\n        convexity_sum = 0.0\n\n        for cf in cash_flows.coupon_payments:\n            days_to_payment = (cf.payment_date - valuation_date).days\n            t = days_to_payment / 365.0\n            discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (t * compounding))\n            pv = cf.coupon_amount * discount_factor\n            convexity_sum += pv * t * (t + 1)\n\n        # Principal\n        days_to_maturity = (self.maturity_date - valuation_date).days\n        t = days_to_maturity / 365.0\n        discount_factor = 1 / ((1 + yield_to_maturity / compounding) ** (t * compounding))\n        pv = self.face_value * discount_factor\n        convexity_sum += pv * t * (t + 1)\n\n        return convexity_sum / (price * (1 + yield_to_maturity / compounding) ** 2)\n\n    def get_summary(self) -&gt; dict:\n        \"\"\"Get bond summary information\"\"\"\n        tenor_years = (self.maturity_date - self.issue_date).days / 365.0\n\n        return {\n            'instrument_type': 'Treasury Bond',\n            'face_value': f\"${self.face_value:,.2f}\",\n            'coupon_rate': f\"{self.coupon_rate * 100:.3f}%\",\n            'issue_date': self.issue_date.strftime('%Y-%m-%d'),\n            'maturity': self.maturity_date.strftime('%Y-%m-%d'),\n            'tenor': f\"{tenor_years:.2f} years\",\n            'payment_frequency': f\"{self.payment_frequency}x per year\",\n            'day_count': self.day_count,\n            'annual_coupon': f\"${self.face_value * self.coupon_rate:,.2f}\"\n        }\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#usage-examples","title":"\ud83d\udcca Usage Examples","text":""},{"location":"instruments/fixed_income/treasury_bond/#example-1-create-a-10-year-treasury-bond","title":"Example 1: Create a 10-Year Treasury Bond","text":"<pre><code>from datetime import datetime\n\n# Create a 10-year Treasury Bond\n# Face value: $1,000, Coupon: 3.5%, Semi-annual payments\ntreasury = TreasuryBond(\n    face_value=1000.0,\n    coupon_rate=0.035,  # 3.5% annual coupon\n    issue_date=datetime(2025, 1, 15),\n    maturity_date=datetime(2035, 1, 15),\n    payment_frequency=2,  # Semi-annual\n    day_count=\"ACT/ACT\"\n)\n\n# Get summary\nprint(\"Treasury Bond Summary:\")\nfor key, value in treasury.get_summary().items():\n    print(f\"  {key}: {value}\")\n</code></pre> <p>Output: <pre><code>Treasury Bond Summary:\n  instrument_type: Treasury Bond\n  face_value: $1,000.00\n  coupon_rate: 3.500%\n  issue_date: 2025-01-15\n  maturity: 2035-01-15\n  tenor: 10.00 years\n  payment_frequency: 2x per year\n  day_count: ACT/ACT\n  annual_coupon: $35.00\n</code></pre></p>"},{"location":"instruments/fixed_income/treasury_bond/#example-2-calculate-bond-price","title":"Example 2: Calculate Bond Price","text":"<pre><code># Calculate price given a yield to maturity of 4%\nytm = 0.04\nvaluation_date = datetime(2025, 1, 15)\n\nprice = treasury.calculate_price(\n    yield_to_maturity=ytm,\n    valuation_date=valuation_date,\n    compounding=2\n)\n\nprint(f\"\\nBond Price at {ytm*100:.2f}% YTM: ${price:.2f}\")\nprint(f\"Price as % of par: {price/treasury.face_value*100:.3f}%\")\n\n# Calculate at different yields\nprint(\"\\nPrice-Yield Relationship:\")\nyields = [0.02, 0.03, 0.035, 0.04, 0.05]\nfor y in yields:\n    p = treasury.calculate_price(y, valuation_date)\n    print(f\"  YTM {y*100:.1f}%: ${p:.2f} ({p/1000*100:.2f}% of par)\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#example-3-calculate-yield-from-market-price","title":"Example 3: Calculate Yield from Market Price","text":"<pre><code># Bond trading at $950 in the market\nmarket_price = 950.00\n\ncalculated_ytm = treasury.calculate_yield(\n    market_price=market_price,\n    valuation_date=valuation_date,\n    compounding=2\n)\n\nprint(f\"\\nMarket Price: ${market_price:.2f}\")\nprint(f\"Calculated YTM: {calculated_ytm*100:.4f}%\")\nprint(f\"Current Yield: {(treasury.face_value * treasury.coupon_rate / market_price)*100:.4f}%\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#example-4-duration-and-convexity-analysis","title":"Example 4: Duration and Convexity Analysis","text":"<pre><code>ytm = 0.04\n\n# Calculate duration metrics\nduration_metrics = treasury.calculate_duration(\n    yield_to_maturity=ytm,\n    valuation_date=valuation_date\n)\n\n# Calculate convexity\nconvexity = treasury.calculate_convexity(\n    yield_to_maturity=ytm,\n    valuation_date=valuation_date\n)\n\nprint(\"\\nRisk Metrics:\")\nprint(f\"  Macaulay Duration: {duration_metrics['macaulay_duration']:.4f} years\")\nprint(f\"  Modified Duration: {duration_metrics['modified_duration']:.4f} years\")\nprint(f\"  Dollar Duration: ${duration_metrics['price_sensitivity']:.2f}\")\nprint(f\"  Convexity: {convexity:.6f}\")\n\n# Price sensitivity analysis\nprint(\"\\n1% Yield Change Impact:\")\ndelta_y = 0.01\nprice_base = treasury.calculate_price(ytm, valuation_date)\nprice_up = treasury.calculate_price(ytm + delta_y, valuation_date)\nprice_down = treasury.calculate_price(ytm - delta_y, valuation_date)\n\nprint(f\"  Base Price: ${price_base:.2f}\")\nprint(f\"  Price if yield +100bp: ${price_up:.2f} ({(price_up-price_base):.2f})\")\nprint(f\"  Price if yield -100bp: ${price_down:.2f} ({(price_down-price_base):.2f})\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#example-5-cash-flow-schedule","title":"Example 5: Cash Flow Schedule","text":"<pre><code># Generate full cash flow schedule\ncash_flows = treasury.calculate_cash_flows(valuation_date)\n\nprint(\"\\nCoupon Payment Schedule:\")\nprint(\"-\" * 70)\nprint(f\"{'Date':&lt;15} {'Coupon':&lt;12} {'Days':&lt;10} {'Cumulative'}\")\nprint(\"-\" * 70)\n\ncumulative = 0\nfor cf in cash_flows.coupon_payments[:10]:  # Show first 10 payments\n    cumulative += cf.coupon_amount\n    print(f\"{cf.payment_date.strftime('%Y-%m-%d'):&lt;15} \"\n          f\"${cf.coupon_amount:&gt;10,.2f} \"\n          f\"{cf.accrued_days:&gt;8}d \"\n          f\"${cumulative:&gt;12,.2f}\")\n\nprint(f\"\\nPrincipal at Maturity: ${cash_flows.principal_payment:,.2f}\")\nprint(f\"Total Coupons: ${sum(cf.coupon_amount for cf in cash_flows.coupon_payments):,.2f}\")\nprint(f\"Total Cash Flow: ${cash_flows.principal_payment + sum(cf.coupon_amount for cf in cash_flows.coupon_payments):,.2f}\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#use-cases","title":"\ud83c\udfaf Use Cases","text":""},{"location":"instruments/fixed_income/treasury_bond/#1-yield-curve-construction","title":"1. Yield Curve Construction","text":"<pre><code># Multiple Treasury bonds for yield curve\nbonds = [\n    TreasuryBond(1000, 0.025, datetime(2025, 1, 15), datetime(2027, 1, 15), 2),  # 2Y\n    TreasuryBond(1000, 0.030, datetime(2025, 1, 15), datetime(2030, 1, 15), 2),  # 5Y\n    TreasuryBond(1000, 0.035, datetime(2025, 1, 15), datetime(2035, 1, 15), 2),  # 10Y\n    TreasuryBond(1000, 0.040, datetime(2025, 1, 15), datetime(2055, 1, 15), 2),  # 30Y\n]\n\nmarket_prices = [985, 970, 950, 920]\n\nprint(\"Treasury Yield Curve:\")\nprint(f\"{'Tenor':&lt;10} {'Price':&lt;12} {'YTM':&lt;10} {'Duration'}\")\nprint(\"-\" * 50)\n\nfor bond, price in zip(bonds, market_prices):\n    tenor = (bond.maturity_date - bond.issue_date).days / 365.0\n    ytm = bond.calculate_yield(price, datetime(2025, 1, 15))\n    duration = bond.calculate_duration(ytm, datetime(2025, 1, 15))\n\n    print(f\"{tenor:&lt;10.1f} ${price:&lt;10,.2f} {ytm*100:&gt;6.3f}% {duration['modified_duration']:&gt;8.3f}\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#2-portfolio-duration-matching","title":"2. Portfolio Duration Matching","text":"<pre><code># Duration matching for liability management\nliability_duration = 7.5  # years\ntotal_portfolio = 10_000_000  # $10M\n\n# Find bond combination to match duration\nbond_5y = TreasuryBond(1000, 0.030, datetime(2025, 1, 15), datetime(2030, 1, 15), 2)\nbond_10y = TreasuryBond(1000, 0.035, datetime(2025, 1, 15), datetime(2035, 1, 15), 2)\n\ndur_5y = bond_5y.calculate_duration(0.04, datetime(2025, 1, 15))['modified_duration']\ndur_10y = bond_10y.calculate_duration(0.04, datetime(2025, 1, 15))['modified_duration']\n\n# Weight calculation: w * dur_5y + (1-w) * dur_10y = target_duration\nweight_5y = (dur_10y - liability_duration) / (dur_10y - dur_5y)\nweight_10y = 1 - weight_5y\n\nprint(f\"Portfolio Duration Matching:\")\nprint(f\"  Target Duration: {liability_duration:.2f} years\")\nprint(f\"  5Y Bond Weight: {weight_5y*100:.2f}% (${total_portfolio * weight_5y:,.0f})\")\nprint(f\"  10Y Bond Weight: {weight_10y*100:.2f}% (${total_portfolio * weight_10y:,.0f})\")\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#advanced-pricing-with-quantlib","title":"\ud83d\udcc8 Advanced Pricing with QuantLib","text":"<pre><code>import QuantLib as ql\n\ndef price_treasury_with_quantlib(\n    face_value: float,\n    coupon_rate: float,\n    issue_date: datetime,\n    maturity_date: datetime,\n    settlement_date: datetime,\n    discount_curve_handle: ql.YieldTermStructureHandle\n) -&gt; dict:\n    \"\"\"\n    Price Treasury bond using QuantLib\n\n    Returns:\n        Dictionary with NPV, clean price, accrued interest, etc.\n    \"\"\"\n    # Convert dates\n    ql_issue = ql.Date(issue_date.day, issue_date.month, issue_date.year)\n    ql_maturity = ql.Date(maturity_date.day, maturity_date.month, maturity_date.year)\n    ql_settlement = ql.Date(settlement_date.day, settlement_date.month, settlement_date.year)\n\n    # Set evaluation date\n    ql.Settings.instance().evaluationDate = ql_settlement\n\n    # Create schedule\n    schedule = ql.Schedule(\n        ql_issue,\n        ql_maturity,\n        ql.Period(ql.Semiannual),\n        ql.UnitedStates(ql.UnitedStates.GovernmentBond),\n        ql.Unadjusted,\n        ql.Unadjusted,\n        ql.DateGeneration.Backward,\n        False\n    )\n\n    # Create bond\n    bond = ql.FixedRateBond(\n        2,  # settlement days\n        face_value,\n        schedule,\n        [coupon_rate],\n        ql.ActualActual(ql.ActualActual.Bond)\n    )\n\n    # Set pricing engine\n    bond_engine = ql.DiscountingBondEngine(discount_curve_handle)\n    bond.setPricingEngine(bond_engine)\n\n    return {\n        'npv': bond.NPV(),\n        'clean_price': bond.cleanPrice(),\n        'dirty_price': bond.dirtyPrice(),\n        'accrued_interest': bond.accruedAmount(),\n        'yield': bond.bondYield(ql.ActualActual(ql.ActualActual.Bond), ql.Compounded, ql.Semiannual)\n    }\n</code></pre>"},{"location":"instruments/fixed_income/treasury_bond/#related-instruments","title":"\ud83d\udd17 Related Instruments","text":"<ul> <li>Callable Bond - Bond with embedded call option</li> <li>Floating Rate Note - Variable coupon payments</li> <li>Interest Rate Swap - Fixed vs floating rate exchange</li> </ul>"},{"location":"instruments/fixed_income/treasury_bond/#references","title":"\ud83d\udcda References","text":"<ul> <li>U.S. Department of the Treasury - TreasuryDirect</li> <li>Fabozzi, F. J. (2007). Fixed Income Analysis</li> <li>QuantLib Fixed Income Documentation</li> </ul>"},{"location":"instruments/fixed_income/treasury_bond/#important-notes","title":"\u26a0\ufe0f Important Notes","text":"<p>Interest Rate Risk</p> <p>Treasury bonds have significant interest rate risk - prices fall when yields rise</p> <p>Inflation Risk</p> <p>Fixed coupon payments lose purchasing power in inflationary environments</p> <p>Benchmark Role</p> <p>Treasury yields serve as risk-free rates for discounting other instruments</p> <p>Last Updated: 2025-01-17 | Version: 1.0 | Status: Production Ready</p>"},{"location":"instruments/fx/currency_forward/","title":"currency forward","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/fx/currency_forward/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/fx/currency_forward/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/fx/currency_forward/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"},{"location":"instruments/rates/irs/","title":"irs","text":"<p>Documentation coming soon.</p>"},{"location":"instruments/rates/irs/#overview","title":"Overview","text":"<p>Details about this instrument will be added here.</p>"},{"location":"instruments/rates/irs/#pricing-methods","title":"Pricing Methods","text":"<ul> <li>Method 1</li> <li>Method 2</li> </ul>"},{"location":"instruments/rates/irs/#example-code","title":"Example Code","text":"<pre><code>import QuantLib as ql\n# Example code\n</code></pre>"}]}